// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core/Tron.proto

#ifndef PROTOBUF_core_2fTron_2eproto__INCLUDED
#define PROTOBUF_core_2fTron_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "core/Discover.pb.h"
// @@protoc_insertion_point(includes)
namespace protocol {
class Account;
class AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountId;
class AccountIdDefaultTypeInternal;
extern AccountIdDefaultTypeInternal _AccountId_default_instance_;
class Account_AssetEntry;
class Account_AssetEntryDefaultTypeInternal;
extern Account_AssetEntryDefaultTypeInternal _Account_AssetEntry_default_instance_;
class Account_FreeAssetNetUsageEntry;
class Account_FreeAssetNetUsageEntryDefaultTypeInternal;
extern Account_FreeAssetNetUsageEntryDefaultTypeInternal _Account_FreeAssetNetUsageEntry_default_instance_;
class Account_Frozen;
class Account_FrozenDefaultTypeInternal;
extern Account_FrozenDefaultTypeInternal _Account_Frozen_default_instance_;
class Account_LatestAssetOperationTimeEntry;
class Account_LatestAssetOperationTimeEntryDefaultTypeInternal;
extern Account_LatestAssetOperationTimeEntryDefaultTypeInternal _Account_LatestAssetOperationTimeEntry_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockHeader;
class BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockHeader_raw;
class BlockHeader_rawDefaultTypeInternal;
extern BlockHeader_rawDefaultTypeInternal _BlockHeader_raw_default_instance_;
class BlockInventory;
class BlockInventoryDefaultTypeInternal;
extern BlockInventoryDefaultTypeInternal _BlockInventory_default_instance_;
class BlockInventory_BlockId;
class BlockInventory_BlockIdDefaultTypeInternal;
extern BlockInventory_BlockIdDefaultTypeInternal _BlockInventory_BlockId_default_instance_;
class ChainInventory;
class ChainInventoryDefaultTypeInternal;
extern ChainInventoryDefaultTypeInternal _ChainInventory_default_instance_;
class ChainInventory_BlockId;
class ChainInventory_BlockIdDefaultTypeInternal;
extern ChainInventory_BlockIdDefaultTypeInternal _ChainInventory_BlockId_default_instance_;
class DisconnectMessage;
class DisconnectMessageDefaultTypeInternal;
extern DisconnectMessageDefaultTypeInternal _DisconnectMessage_default_instance_;
class DynamicProperties;
class DynamicPropertiesDefaultTypeInternal;
extern DynamicPropertiesDefaultTypeInternal _DynamicProperties_default_instance_;
class HelloMessage;
class HelloMessageDefaultTypeInternal;
extern HelloMessageDefaultTypeInternal _HelloMessage_default_instance_;
class HelloMessage_BlockId;
class HelloMessage_BlockIdDefaultTypeInternal;
extern HelloMessage_BlockIdDefaultTypeInternal _HelloMessage_BlockId_default_instance_;
class Inventory;
class InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class Items;
class ItemsDefaultTypeInternal;
extern ItemsDefaultTypeInternal _Items_default_instance_;
class TXInput;
class TXInputDefaultTypeInternal;
extern TXInputDefaultTypeInternal _TXInput_default_instance_;
class TXInput_raw;
class TXInput_rawDefaultTypeInternal;
extern TXInput_rawDefaultTypeInternal _TXInput_raw_default_instance_;
class TXOutput;
class TXOutputDefaultTypeInternal;
extern TXOutputDefaultTypeInternal _TXOutput_default_instance_;
class TXOutputs;
class TXOutputsDefaultTypeInternal;
extern TXOutputsDefaultTypeInternal _TXOutputs_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class Transaction_Contract;
class Transaction_ContractDefaultTypeInternal;
extern Transaction_ContractDefaultTypeInternal _Transaction_Contract_default_instance_;
class Transaction_Result;
class Transaction_ResultDefaultTypeInternal;
extern Transaction_ResultDefaultTypeInternal _Transaction_Result_default_instance_;
class Transaction_raw;
class Transaction_rawDefaultTypeInternal;
extern Transaction_rawDefaultTypeInternal _Transaction_raw_default_instance_;
class Transactions;
class TransactionsDefaultTypeInternal;
extern TransactionsDefaultTypeInternal _Transactions_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
class Votes;
class VotesDefaultTypeInternal;
extern VotesDefaultTypeInternal _Votes_default_instance_;
class Witness;
class WitnessDefaultTypeInternal;
extern WitnessDefaultTypeInternal _Witness_default_instance_;
class acuthrity;
class acuthrityDefaultTypeInternal;
extern acuthrityDefaultTypeInternal _acuthrity_default_instance_;
class permision;
class permisionDefaultTypeInternal;
extern permisionDefaultTypeInternal _permision_default_instance_;
}  // namespace protocol

namespace protocol {

namespace protobuf_core_2fTron_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_core_2fTron_2eproto

enum Transaction_Contract_ContractType {
  Transaction_Contract_ContractType_AccountCreateContract = 0,
  Transaction_Contract_ContractType_TransferContract = 1,
  Transaction_Contract_ContractType_TransferAssetContract = 2,
  Transaction_Contract_ContractType_VoteAssetContract = 3,
  Transaction_Contract_ContractType_VoteWitnessContract = 4,
  Transaction_Contract_ContractType_WitnessCreateContract = 5,
  Transaction_Contract_ContractType_AssetIssueContract = 6,
  Transaction_Contract_ContractType_DeployContract = 7,
  Transaction_Contract_ContractType_WitnessUpdateContract = 8,
  Transaction_Contract_ContractType_ParticipateAssetIssueContract = 9,
  Transaction_Contract_ContractType_AccountUpdateContract = 10,
  Transaction_Contract_ContractType_FreezeBalanceContract = 11,
  Transaction_Contract_ContractType_UnfreezeBalanceContract = 12,
  Transaction_Contract_ContractType_WithdrawBalanceContract = 13,
  Transaction_Contract_ContractType_UnfreezeAssetContract = 14,
  Transaction_Contract_ContractType_UpdateAssetContract = 15,
  Transaction_Contract_ContractType_CustomContract = 20,
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Transaction_Contract_ContractType_IsValid(int value);
const Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MIN = Transaction_Contract_ContractType_AccountCreateContract;
const Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MAX = Transaction_Contract_ContractType_CustomContract;
const int Transaction_Contract_ContractType_ContractType_ARRAYSIZE = Transaction_Contract_ContractType_ContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Contract_ContractType_descriptor();
inline const ::std::string& Transaction_Contract_ContractType_Name(Transaction_Contract_ContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Contract_ContractType_descriptor(), value);
}
inline bool Transaction_Contract_ContractType_Parse(
    const ::std::string& name, Transaction_Contract_ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Contract_ContractType>(
    Transaction_Contract_ContractType_descriptor(), name, value);
}
enum Transaction_Result_code {
  Transaction_Result_code_SUCESS = 0,
  Transaction_Result_code_FAILED = 1,
  Transaction_Result_code_Transaction_Result_code_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Transaction_Result_code_Transaction_Result_code_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Transaction_Result_code_IsValid(int value);
const Transaction_Result_code Transaction_Result_code_code_MIN = Transaction_Result_code_SUCESS;
const Transaction_Result_code Transaction_Result_code_code_MAX = Transaction_Result_code_FAILED;
const int Transaction_Result_code_code_ARRAYSIZE = Transaction_Result_code_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Result_code_descriptor();
inline const ::std::string& Transaction_Result_code_Name(Transaction_Result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Result_code_descriptor(), value);
}
inline bool Transaction_Result_code_Parse(
    const ::std::string& name, Transaction_Result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Result_code>(
    Transaction_Result_code_descriptor(), name, value);
}
enum BlockInventory_Type {
  BlockInventory_Type_SYNC = 0,
  BlockInventory_Type_ADVTISE = 1,
  BlockInventory_Type_FETCH = 2,
  BlockInventory_Type_BlockInventory_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BlockInventory_Type_BlockInventory_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BlockInventory_Type_IsValid(int value);
const BlockInventory_Type BlockInventory_Type_Type_MIN = BlockInventory_Type_SYNC;
const BlockInventory_Type BlockInventory_Type_Type_MAX = BlockInventory_Type_FETCH;
const int BlockInventory_Type_Type_ARRAYSIZE = BlockInventory_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlockInventory_Type_descriptor();
inline const ::std::string& BlockInventory_Type_Name(BlockInventory_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlockInventory_Type_descriptor(), value);
}
inline bool BlockInventory_Type_Parse(
    const ::std::string& name, BlockInventory_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockInventory_Type>(
    BlockInventory_Type_descriptor(), name, value);
}
enum Inventory_InventoryType {
  Inventory_InventoryType_TRX = 0,
  Inventory_InventoryType_BLOCK = 1,
  Inventory_InventoryType_Inventory_InventoryType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Inventory_InventoryType_Inventory_InventoryType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Inventory_InventoryType_IsValid(int value);
const Inventory_InventoryType Inventory_InventoryType_InventoryType_MIN = Inventory_InventoryType_TRX;
const Inventory_InventoryType Inventory_InventoryType_InventoryType_MAX = Inventory_InventoryType_BLOCK;
const int Inventory_InventoryType_InventoryType_ARRAYSIZE = Inventory_InventoryType_InventoryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Inventory_InventoryType_descriptor();
inline const ::std::string& Inventory_InventoryType_Name(Inventory_InventoryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Inventory_InventoryType_descriptor(), value);
}
inline bool Inventory_InventoryType_Parse(
    const ::std::string& name, Inventory_InventoryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Inventory_InventoryType>(
    Inventory_InventoryType_descriptor(), name, value);
}
enum Items_ItemType {
  Items_ItemType_ERR = 0,
  Items_ItemType_TRX = 1,
  Items_ItemType_BLOCK = 2,
  Items_ItemType_BLOCKHEADER = 3,
  Items_ItemType_Items_ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Items_ItemType_Items_ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Items_ItemType_IsValid(int value);
const Items_ItemType Items_ItemType_ItemType_MIN = Items_ItemType_ERR;
const Items_ItemType Items_ItemType_ItemType_MAX = Items_ItemType_BLOCKHEADER;
const int Items_ItemType_ItemType_ARRAYSIZE = Items_ItemType_ItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Items_ItemType_descriptor();
inline const ::std::string& Items_ItemType_Name(Items_ItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Items_ItemType_descriptor(), value);
}
inline bool Items_ItemType_Parse(
    const ::std::string& name, Items_ItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Items_ItemType>(
    Items_ItemType_descriptor(), name, value);
}
enum AccountType {
  Normal = 0,
  AssetIssue = 1,
  Contract = 2,
  AccountType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AccountType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AccountType_IsValid(int value);
const AccountType AccountType_MIN = Normal;
const AccountType AccountType_MAX = Contract;
const int AccountType_ARRAYSIZE = AccountType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountType_descriptor();
inline const ::std::string& AccountType_Name(AccountType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountType_descriptor(), value);
}
inline bool AccountType_Parse(
    const ::std::string& name, AccountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountType>(
    AccountType_descriptor(), name, value);
}
enum ReasonCode {
  REQUESTED = 0,
  BAD_PROTOCOL = 2,
  TOO_MANY_PEERS = 4,
  DUPLICATE_PEER = 5,
  INCOMPATIBLE_PROTOCOL = 6,
  NULL_IDENTITY = 7,
  PEER_QUITING = 8,
  UNEXPECTED_IDENTITY = 9,
  LOCAL_IDENTITY = 10,
  PING_TIMEOUT = 11,
  USER_REASON = 16,
  RESET = 17,
  SYNC_FAIL = 18,
  FETCH_FAIL = 19,
  BAD_TX = 20,
  BAD_BLOCK = 21,
  FORKED = 22,
  UNLINKABLE = 23,
  INCOMPATIBLE_VERSION = 24,
  INCOMPATIBLE_CHAIN = 25,
  TIME_OUT = 32,
  CONNECT_FAIL = 33,
  UNKNOWN = 255,
  ReasonCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReasonCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReasonCode_IsValid(int value);
const ReasonCode ReasonCode_MIN = REQUESTED;
const ReasonCode ReasonCode_MAX = UNKNOWN;
const int ReasonCode_ARRAYSIZE = ReasonCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReasonCode_descriptor();
inline const ::std::string& ReasonCode_Name(ReasonCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReasonCode_descriptor(), value);
}
inline bool ReasonCode_Parse(
    const ::std::string& name, ReasonCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReasonCode>(
    ReasonCode_descriptor(), name, value);
}
// ===================================================================

class AccountId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AccountId) */ {
 public:
  AccountId();
  virtual ~AccountId();

  AccountId(const AccountId& from);

  inline AccountId& operator=(const AccountId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountId(AccountId&& from) noexcept
    : AccountId() {
    *this = ::std::move(from);
  }

  inline AccountId& operator=(AccountId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountId& default_instance();

  static inline const AccountId* internal_default_instance() {
    return reinterpret_cast<const AccountId*>(
               &_AccountId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AccountId* other);
  friend void swap(AccountId& a, AccountId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountId* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountId& from);
  void MergeFrom(const AccountId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:protocol.AccountId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Vote) */ {
 public:
  Vote();
  virtual ~Vote();

  Vote(const Vote& from);

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vote& default_instance();

  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Vote* other);
  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const PROTOBUF_FINAL { return New(NULL); }

  Vote* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes vote_address = 1;
  void clear_vote_address();
  static const int kVoteAddressFieldNumber = 1;
  const ::std::string& vote_address() const;
  void set_vote_address(const ::std::string& value);
  #if LANG_CXX11
  void set_vote_address(::std::string&& value);
  #endif
  void set_vote_address(const char* value);
  void set_vote_address(const void* value, size_t size);
  ::std::string* mutable_vote_address();
  ::std::string* release_vote_address();
  void set_allocated_vote_address(::std::string* vote_address);

  // int64 vote_count = 2;
  void clear_vote_count();
  static const int kVoteCountFieldNumber = 2;
  ::google::protobuf::int64 vote_count() const;
  void set_vote_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Vote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vote_address_;
  ::google::protobuf::int64 vote_count_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Account_Frozen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Account.Frozen) */ {
 public:
  Account_Frozen();
  virtual ~Account_Frozen();

  Account_Frozen(const Account_Frozen& from);

  inline Account_Frozen& operator=(const Account_Frozen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Account_Frozen(Account_Frozen&& from) noexcept
    : Account_Frozen() {
    *this = ::std::move(from);
  }

  inline Account_Frozen& operator=(Account_Frozen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account_Frozen& default_instance();

  static inline const Account_Frozen* internal_default_instance() {
    return reinterpret_cast<const Account_Frozen*>(
               &_Account_Frozen_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Account_Frozen* other);
  friend void swap(Account_Frozen& a, Account_Frozen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Account_Frozen* New() const PROTOBUF_FINAL { return New(NULL); }

  Account_Frozen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Account_Frozen& from);
  void MergeFrom(const Account_Frozen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Account_Frozen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 frozen_balance = 1;
  void clear_frozen_balance();
  static const int kFrozenBalanceFieldNumber = 1;
  ::google::protobuf::int64 frozen_balance() const;
  void set_frozen_balance(::google::protobuf::int64 value);

  // int64 expire_time = 2;
  void clear_expire_time();
  static const int kExpireTimeFieldNumber = 2;
  ::google::protobuf::int64 expire_time() const;
  void set_expire_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Account.Frozen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 frozen_balance_;
  ::google::protobuf::int64 expire_time_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(Account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Account* other);
  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const PROTOBUF_FINAL { return New(NULL); }

  Account* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Account_Frozen Frozen;

  // accessors -------------------------------------------------------

  // repeated .protocol.Vote votes = 5;
  int votes_size() const;
  void clear_votes();
  static const int kVotesFieldNumber = 5;
  const ::protocol::Vote& votes(int index) const;
  ::protocol::Vote* mutable_votes(int index);
  ::protocol::Vote* add_votes();
  ::google::protobuf::RepeatedPtrField< ::protocol::Vote >*
      mutable_votes();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Vote >&
      votes() const;

  // map<string, int64> asset = 6;
  int asset_size() const;
  void clear_asset();
  static const int kAssetFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
      asset() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
      mutable_asset();

  // repeated .protocol.Account.Frozen frozen = 7;
  int frozen_size() const;
  void clear_frozen();
  static const int kFrozenFieldNumber = 7;
  const ::protocol::Account_Frozen& frozen(int index) const;
  ::protocol::Account_Frozen* mutable_frozen(int index);
  ::protocol::Account_Frozen* add_frozen();
  ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >*
      mutable_frozen();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >&
      frozen() const;

  // repeated .protocol.Account.Frozen frozen_supply = 16;
  int frozen_supply_size() const;
  void clear_frozen_supply();
  static const int kFrozenSupplyFieldNumber = 16;
  const ::protocol::Account_Frozen& frozen_supply(int index) const;
  ::protocol::Account_Frozen* mutable_frozen_supply(int index);
  ::protocol::Account_Frozen* add_frozen_supply();
  ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >*
      mutable_frozen_supply();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >&
      frozen_supply() const;

  // map<string, int64> latest_asset_operation_time = 18;
  int latest_asset_operation_time_size() const;
  void clear_latest_asset_operation_time();
  static const int kLatestAssetOperationTimeFieldNumber = 18;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
      latest_asset_operation_time() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
      mutable_latest_asset_operation_time();

  // map<string, int64> free_asset_net_usage = 20;
  int free_asset_net_usage_size() const;
  void clear_free_asset_net_usage();
  static const int kFreeAssetNetUsageFieldNumber = 20;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
      free_asset_net_usage() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
      mutable_free_asset_net_usage();

  // bytes account_name = 1;
  void clear_account_name();
  static const int kAccountNameFieldNumber = 1;
  const ::std::string& account_name() const;
  void set_account_name(const ::std::string& value);
  #if LANG_CXX11
  void set_account_name(::std::string&& value);
  #endif
  void set_account_name(const char* value);
  void set_account_name(const void* value, size_t size);
  ::std::string* mutable_account_name();
  ::std::string* release_account_name();
  void set_allocated_account_name(::std::string* account_name);

  // bytes address = 3;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // bytes code = 13;
  void clear_code();
  static const int kCodeFieldNumber = 13;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const void* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // bytes asset_issued_name = 17;
  void clear_asset_issued_name();
  static const int kAssetIssuedNameFieldNumber = 17;
  const ::std::string& asset_issued_name() const;
  void set_asset_issued_name(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_issued_name(::std::string&& value);
  #endif
  void set_asset_issued_name(const char* value);
  void set_asset_issued_name(const void* value, size_t size);
  ::std::string* mutable_asset_issued_name();
  ::std::string* release_asset_issued_name();
  void set_allocated_asset_issued_name(::std::string* asset_issued_name);

  // int64 balance = 4;
  void clear_balance();
  static const int kBalanceFieldNumber = 4;
  ::google::protobuf::int64 balance() const;
  void set_balance(::google::protobuf::int64 value);

  // int64 net_usage = 8;
  void clear_net_usage();
  static const int kNetUsageFieldNumber = 8;
  ::google::protobuf::int64 net_usage() const;
  void set_net_usage(::google::protobuf::int64 value);

  // int64 create_time = 9;
  void clear_create_time();
  static const int kCreateTimeFieldNumber = 9;
  ::google::protobuf::int64 create_time() const;
  void set_create_time(::google::protobuf::int64 value);

  // int64 latest_opration_time = 10;
  void clear_latest_opration_time();
  static const int kLatestOprationTimeFieldNumber = 10;
  ::google::protobuf::int64 latest_opration_time() const;
  void set_latest_opration_time(::google::protobuf::int64 value);

  // .protocol.AccountType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::protocol::AccountType type() const;
  void set_type(::protocol::AccountType value);

  // bool is_witness = 14;
  void clear_is_witness();
  static const int kIsWitnessFieldNumber = 14;
  bool is_witness() const;
  void set_is_witness(bool value);

  // bool is_committee = 15;
  void clear_is_committee();
  static const int kIsCommitteeFieldNumber = 15;
  bool is_committee() const;
  void set_is_committee(bool value);

  // int64 allowance = 11;
  void clear_allowance();
  static const int kAllowanceFieldNumber = 11;
  ::google::protobuf::int64 allowance() const;
  void set_allowance(::google::protobuf::int64 value);

  // int64 latest_withdraw_time = 12;
  void clear_latest_withdraw_time();
  static const int kLatestWithdrawTimeFieldNumber = 12;
  ::google::protobuf::int64 latest_withdraw_time() const;
  void set_latest_withdraw_time(::google::protobuf::int64 value);

  // int64 free_net_usage = 19;
  void clear_free_net_usage();
  static const int kFreeNetUsageFieldNumber = 19;
  ::google::protobuf::int64 free_net_usage() const;
  void set_free_net_usage(::google::protobuf::int64 value);

  // int64 latest_consume_time = 21;
  void clear_latest_consume_time();
  static const int kLatestConsumeTimeFieldNumber = 21;
  ::google::protobuf::int64 latest_consume_time() const;
  void set_latest_consume_time(::google::protobuf::int64 value);

  // int64 latest_consume_free_time = 22;
  void clear_latest_consume_free_time();
  static const int kLatestConsumeFreeTimeFieldNumber = 22;
  ::google::protobuf::int64 latest_consume_free_time() const;
  void set_latest_consume_free_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Vote > votes_;
  public:
  class Account_AssetEntry : public ::google::protobuf::internal::MapEntry<Account_AssetEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<Account_AssetEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > SuperType;
    Account_AssetEntry();
    Account_AssetEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const Account_AssetEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_Account_AssetEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      Account_AssetEntry,
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > asset_;
  private:
  ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen > frozen_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen > frozen_supply_;
  public:
  class Account_LatestAssetOperationTimeEntry : public ::google::protobuf::internal::MapEntry<Account_LatestAssetOperationTimeEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<Account_LatestAssetOperationTimeEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > SuperType;
    Account_LatestAssetOperationTimeEntry();
    Account_LatestAssetOperationTimeEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const Account_LatestAssetOperationTimeEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_Account_LatestAssetOperationTimeEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      Account_LatestAssetOperationTimeEntry,
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > latest_asset_operation_time_;
  private:
  public:
  class Account_FreeAssetNetUsageEntry : public ::google::protobuf::internal::MapEntry<Account_FreeAssetNetUsageEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<Account_FreeAssetNetUsageEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > SuperType;
    Account_FreeAssetNetUsageEntry();
    Account_FreeAssetNetUsageEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const Account_FreeAssetNetUsageEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_Account_FreeAssetNetUsageEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      Account_FreeAssetNetUsageEntry,
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > free_asset_net_usage_;
  private:
  ::google::protobuf::internal::ArenaStringPtr account_name_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr asset_issued_name_;
  ::google::protobuf::int64 balance_;
  ::google::protobuf::int64 net_usage_;
  ::google::protobuf::int64 create_time_;
  ::google::protobuf::int64 latest_opration_time_;
  int type_;
  bool is_witness_;
  bool is_committee_;
  ::google::protobuf::int64 allowance_;
  ::google::protobuf::int64 latest_withdraw_time_;
  ::google::protobuf::int64 free_net_usage_;
  ::google::protobuf::int64 latest_consume_time_;
  ::google::protobuf::int64 latest_consume_free_time_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class acuthrity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.acuthrity) */ {
 public:
  acuthrity();
  virtual ~acuthrity();

  acuthrity(const acuthrity& from);

  inline acuthrity& operator=(const acuthrity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  acuthrity(acuthrity&& from) noexcept
    : acuthrity() {
    *this = ::std::move(from);
  }

  inline acuthrity& operator=(acuthrity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const acuthrity& default_instance();

  static inline const acuthrity* internal_default_instance() {
    return reinterpret_cast<const acuthrity*>(
               &_acuthrity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(acuthrity* other);
  friend void swap(acuthrity& a, acuthrity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline acuthrity* New() const PROTOBUF_FINAL { return New(NULL); }

  acuthrity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const acuthrity& from);
  void MergeFrom(const acuthrity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(acuthrity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes permission_name = 2;
  void clear_permission_name();
  static const int kPermissionNameFieldNumber = 2;
  const ::std::string& permission_name() const;
  void set_permission_name(const ::std::string& value);
  #if LANG_CXX11
  void set_permission_name(::std::string&& value);
  #endif
  void set_permission_name(const char* value);
  void set_permission_name(const void* value, size_t size);
  ::std::string* mutable_permission_name();
  ::std::string* release_permission_name();
  void set_allocated_permission_name(::std::string* permission_name);

  // .protocol.AccountId account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::protocol::AccountId& account() const;
  ::protocol::AccountId* mutable_account();
  ::protocol::AccountId* release_account();
  void set_allocated_account(::protocol::AccountId* account);

  // @@protoc_insertion_point(class_scope:protocol.acuthrity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr permission_name_;
  ::protocol::AccountId* account_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class permision : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.permision) */ {
 public:
  permision();
  virtual ~permision();

  permision(const permision& from);

  inline permision& operator=(const permision& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  permision(permision&& from) noexcept
    : permision() {
    *this = ::std::move(from);
  }

  inline permision& operator=(permision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const permision& default_instance();

  static inline const permision* internal_default_instance() {
    return reinterpret_cast<const permision*>(
               &_permision_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(permision* other);
  friend void swap(permision& a, permision& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline permision* New() const PROTOBUF_FINAL { return New(NULL); }

  permision* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const permision& from);
  void MergeFrom(const permision& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(permision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .protocol.AccountId account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::protocol::AccountId& account() const;
  ::protocol::AccountId* mutable_account();
  ::protocol::AccountId* release_account();
  void set_allocated_account(::protocol::AccountId* account);

  // @@protoc_insertion_point(class_scope:protocol.permision)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protocol::AccountId* account_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Witness : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Witness) */ {
 public:
  Witness();
  virtual ~Witness();

  Witness(const Witness& from);

  inline Witness& operator=(const Witness& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Witness(Witness&& from) noexcept
    : Witness() {
    *this = ::std::move(from);
  }

  inline Witness& operator=(Witness&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Witness& default_instance();

  static inline const Witness* internal_default_instance() {
    return reinterpret_cast<const Witness*>(
               &_Witness_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Witness* other);
  friend void swap(Witness& a, Witness& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Witness* New() const PROTOBUF_FINAL { return New(NULL); }

  Witness* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Witness& from);
  void MergeFrom(const Witness& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Witness* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // bytes pubKey = 3;
  void clear_pubkey();
  static const int kPubKeyFieldNumber = 3;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // string url = 4;
  void clear_url();
  static const int kUrlFieldNumber = 4;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // int64 voteCount = 2;
  void clear_votecount();
  static const int kVoteCountFieldNumber = 2;
  ::google::protobuf::int64 votecount() const;
  void set_votecount(::google::protobuf::int64 value);

  // int64 totalProduced = 5;
  void clear_totalproduced();
  static const int kTotalProducedFieldNumber = 5;
  ::google::protobuf::int64 totalproduced() const;
  void set_totalproduced(::google::protobuf::int64 value);

  // int64 totalMissed = 6;
  void clear_totalmissed();
  static const int kTotalMissedFieldNumber = 6;
  ::google::protobuf::int64 totalmissed() const;
  void set_totalmissed(::google::protobuf::int64 value);

  // int64 latestBlockNum = 7;
  void clear_latestblocknum();
  static const int kLatestBlockNumFieldNumber = 7;
  ::google::protobuf::int64 latestblocknum() const;
  void set_latestblocknum(::google::protobuf::int64 value);

  // int64 latestSlotNum = 8;
  void clear_latestslotnum();
  static const int kLatestSlotNumFieldNumber = 8;
  ::google::protobuf::int64 latestslotnum() const;
  void set_latestslotnum(::google::protobuf::int64 value);

  // bool isJobs = 9;
  void clear_isjobs();
  static const int kIsJobsFieldNumber = 9;
  bool isjobs() const;
  void set_isjobs(bool value);

  // @@protoc_insertion_point(class_scope:protocol.Witness)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::int64 votecount_;
  ::google::protobuf::int64 totalproduced_;
  ::google::protobuf::int64 totalmissed_;
  ::google::protobuf::int64 latestblocknum_;
  ::google::protobuf::int64 latestslotnum_;
  bool isjobs_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Votes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Votes) */ {
 public:
  Votes();
  virtual ~Votes();

  Votes(const Votes& from);

  inline Votes& operator=(const Votes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Votes(Votes&& from) noexcept
    : Votes() {
    *this = ::std::move(from);
  }

  inline Votes& operator=(Votes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Votes& default_instance();

  static inline const Votes* internal_default_instance() {
    return reinterpret_cast<const Votes*>(
               &_Votes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Votes* other);
  friend void swap(Votes& a, Votes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Votes* New() const PROTOBUF_FINAL { return New(NULL); }

  Votes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Votes& from);
  void MergeFrom(const Votes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Votes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Vote old_votes = 2;
  int old_votes_size() const;
  void clear_old_votes();
  static const int kOldVotesFieldNumber = 2;
  const ::protocol::Vote& old_votes(int index) const;
  ::protocol::Vote* mutable_old_votes(int index);
  ::protocol::Vote* add_old_votes();
  ::google::protobuf::RepeatedPtrField< ::protocol::Vote >*
      mutable_old_votes();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Vote >&
      old_votes() const;

  // repeated .protocol.Vote new_votes = 3;
  int new_votes_size() const;
  void clear_new_votes();
  static const int kNewVotesFieldNumber = 3;
  const ::protocol::Vote& new_votes(int index) const;
  ::protocol::Vote* mutable_new_votes(int index);
  ::protocol::Vote* add_new_votes();
  ::google::protobuf::RepeatedPtrField< ::protocol::Vote >*
      mutable_new_votes();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Vote >&
      new_votes() const;

  // bytes address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:protocol.Votes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Vote > old_votes_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Vote > new_votes_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TXOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TXOutput) */ {
 public:
  TXOutput();
  virtual ~TXOutput();

  TXOutput(const TXOutput& from);

  inline TXOutput& operator=(const TXOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TXOutput(TXOutput&& from) noexcept
    : TXOutput() {
    *this = ::std::move(from);
  }

  inline TXOutput& operator=(TXOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TXOutput& default_instance();

  static inline const TXOutput* internal_default_instance() {
    return reinterpret_cast<const TXOutput*>(
               &_TXOutput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(TXOutput* other);
  friend void swap(TXOutput& a, TXOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TXOutput* New() const PROTOBUF_FINAL { return New(NULL); }

  TXOutput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TXOutput& from);
  void MergeFrom(const TXOutput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TXOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pubKeyHash = 2;
  void clear_pubkeyhash();
  static const int kPubKeyHashFieldNumber = 2;
  const ::std::string& pubkeyhash() const;
  void set_pubkeyhash(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkeyhash(::std::string&& value);
  #endif
  void set_pubkeyhash(const char* value);
  void set_pubkeyhash(const void* value, size_t size);
  ::std::string* mutable_pubkeyhash();
  ::std::string* release_pubkeyhash();
  void set_allocated_pubkeyhash(::std::string* pubkeyhash);

  // int64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TXOutput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pubkeyhash_;
  ::google::protobuf::int64 value_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TXInput_raw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TXInput.raw) */ {
 public:
  TXInput_raw();
  virtual ~TXInput_raw();

  TXInput_raw(const TXInput_raw& from);

  inline TXInput_raw& operator=(const TXInput_raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TXInput_raw(TXInput_raw&& from) noexcept
    : TXInput_raw() {
    *this = ::std::move(from);
  }

  inline TXInput_raw& operator=(TXInput_raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TXInput_raw& default_instance();

  static inline const TXInput_raw* internal_default_instance() {
    return reinterpret_cast<const TXInput_raw*>(
               &_TXInput_raw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TXInput_raw* other);
  friend void swap(TXInput_raw& a, TXInput_raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TXInput_raw* New() const PROTOBUF_FINAL { return New(NULL); }

  TXInput_raw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TXInput_raw& from);
  void MergeFrom(const TXInput_raw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TXInput_raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes txID = 1;
  void clear_txid();
  static const int kTxIDFieldNumber = 1;
  const ::std::string& txid() const;
  void set_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_txid(::std::string&& value);
  #endif
  void set_txid(const char* value);
  void set_txid(const void* value, size_t size);
  ::std::string* mutable_txid();
  ::std::string* release_txid();
  void set_allocated_txid(::std::string* txid);

  // bytes pubKey = 3;
  void clear_pubkey();
  static const int kPubKeyFieldNumber = 3;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // int64 vout = 2;
  void clear_vout();
  static const int kVoutFieldNumber = 2;
  ::google::protobuf::int64 vout() const;
  void set_vout(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TXInput.raw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txid_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::int64 vout_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TXInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TXInput) */ {
 public:
  TXInput();
  virtual ~TXInput();

  TXInput(const TXInput& from);

  inline TXInput& operator=(const TXInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TXInput(TXInput&& from) noexcept
    : TXInput() {
    *this = ::std::move(from);
  }

  inline TXInput& operator=(TXInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TXInput& default_instance();

  static inline const TXInput* internal_default_instance() {
    return reinterpret_cast<const TXInput*>(
               &_TXInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TXInput* other);
  friend void swap(TXInput& a, TXInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TXInput* New() const PROTOBUF_FINAL { return New(NULL); }

  TXInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TXInput& from);
  void MergeFrom(const TXInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TXInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TXInput_raw raw;

  // accessors -------------------------------------------------------

  // bytes signature = 4;
  void clear_signature();
  static const int kSignatureFieldNumber = 4;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // .protocol.TXInput.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::protocol::TXInput_raw& raw_data() const;
  ::protocol::TXInput_raw* mutable_raw_data();
  ::protocol::TXInput_raw* release_raw_data();
  void set_allocated_raw_data(::protocol::TXInput_raw* raw_data);

  // @@protoc_insertion_point(class_scope:protocol.TXInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::protocol::TXInput_raw* raw_data_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TXOutputs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TXOutputs) */ {
 public:
  TXOutputs();
  virtual ~TXOutputs();

  TXOutputs(const TXOutputs& from);

  inline TXOutputs& operator=(const TXOutputs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TXOutputs(TXOutputs&& from) noexcept
    : TXOutputs() {
    *this = ::std::move(from);
  }

  inline TXOutputs& operator=(TXOutputs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TXOutputs& default_instance();

  static inline const TXOutputs* internal_default_instance() {
    return reinterpret_cast<const TXOutputs*>(
               &_TXOutputs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TXOutputs* other);
  friend void swap(TXOutputs& a, TXOutputs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TXOutputs* New() const PROTOBUF_FINAL { return New(NULL); }

  TXOutputs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TXOutputs& from);
  void MergeFrom(const TXOutputs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TXOutputs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.TXOutput outputs = 1;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 1;
  const ::protocol::TXOutput& outputs(int index) const;
  ::protocol::TXOutput* mutable_outputs(int index);
  ::protocol::TXOutput* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::protocol::TXOutput >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::TXOutput >&
      outputs() const;

  // @@protoc_insertion_point(class_scope:protocol.TXOutputs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TXOutput > outputs_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction_Contract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Contract) */ {
 public:
  Transaction_Contract();
  virtual ~Transaction_Contract();

  Transaction_Contract(const Transaction_Contract& from);

  inline Transaction_Contract& operator=(const Transaction_Contract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction_Contract(Transaction_Contract&& from) noexcept
    : Transaction_Contract() {
    *this = ::std::move(from);
  }

  inline Transaction_Contract& operator=(Transaction_Contract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction_Contract& default_instance();

  static inline const Transaction_Contract* internal_default_instance() {
    return reinterpret_cast<const Transaction_Contract*>(
               &_Transaction_Contract_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Transaction_Contract* other);
  friend void swap(Transaction_Contract& a, Transaction_Contract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction_Contract* New() const PROTOBUF_FINAL { return New(NULL); }

  Transaction_Contract* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transaction_Contract& from);
  void MergeFrom(const Transaction_Contract& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transaction_Contract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract_ContractType ContractType;
  static const ContractType AccountCreateContract =
    Transaction_Contract_ContractType_AccountCreateContract;
  static const ContractType TransferContract =
    Transaction_Contract_ContractType_TransferContract;
  static const ContractType TransferAssetContract =
    Transaction_Contract_ContractType_TransferAssetContract;
  static const ContractType VoteAssetContract =
    Transaction_Contract_ContractType_VoteAssetContract;
  static const ContractType VoteWitnessContract =
    Transaction_Contract_ContractType_VoteWitnessContract;
  static const ContractType WitnessCreateContract =
    Transaction_Contract_ContractType_WitnessCreateContract;
  static const ContractType AssetIssueContract =
    Transaction_Contract_ContractType_AssetIssueContract;
  static const ContractType DeployContract =
    Transaction_Contract_ContractType_DeployContract;
  static const ContractType WitnessUpdateContract =
    Transaction_Contract_ContractType_WitnessUpdateContract;
  static const ContractType ParticipateAssetIssueContract =
    Transaction_Contract_ContractType_ParticipateAssetIssueContract;
  static const ContractType AccountUpdateContract =
    Transaction_Contract_ContractType_AccountUpdateContract;
  static const ContractType FreezeBalanceContract =
    Transaction_Contract_ContractType_FreezeBalanceContract;
  static const ContractType UnfreezeBalanceContract =
    Transaction_Contract_ContractType_UnfreezeBalanceContract;
  static const ContractType WithdrawBalanceContract =
    Transaction_Contract_ContractType_WithdrawBalanceContract;
  static const ContractType UnfreezeAssetContract =
    Transaction_Contract_ContractType_UnfreezeAssetContract;
  static const ContractType UpdateAssetContract =
    Transaction_Contract_ContractType_UpdateAssetContract;
  static const ContractType CustomContract =
    Transaction_Contract_ContractType_CustomContract;
  static inline bool ContractType_IsValid(int value) {
    return Transaction_Contract_ContractType_IsValid(value);
  }
  static const ContractType ContractType_MIN =
    Transaction_Contract_ContractType_ContractType_MIN;
  static const ContractType ContractType_MAX =
    Transaction_Contract_ContractType_ContractType_MAX;
  static const int ContractType_ARRAYSIZE =
    Transaction_Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContractType_descriptor() {
    return Transaction_Contract_ContractType_descriptor();
  }
  static inline const ::std::string& ContractType_Name(ContractType value) {
    return Transaction_Contract_ContractType_Name(value);
  }
  static inline bool ContractType_Parse(const ::std::string& name,
      ContractType* value) {
    return Transaction_Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes provider = 3;
  void clear_provider();
  static const int kProviderFieldNumber = 3;
  const ::std::string& provider() const;
  void set_provider(const ::std::string& value);
  #if LANG_CXX11
  void set_provider(::std::string&& value);
  #endif
  void set_provider(const char* value);
  void set_provider(const void* value, size_t size);
  ::std::string* mutable_provider();
  ::std::string* release_provider();
  void set_allocated_provider(::std::string* provider);

  // bytes ContractName = 4;
  void clear_contractname();
  static const int kContractNameFieldNumber = 4;
  const ::std::string& contractname() const;
  void set_contractname(const ::std::string& value);
  #if LANG_CXX11
  void set_contractname(::std::string&& value);
  #endif
  void set_contractname(const char* value);
  void set_contractname(const void* value, size_t size);
  ::std::string* mutable_contractname();
  ::std::string* release_contractname();
  void set_allocated_contractname(::std::string* contractname);

  // .google.protobuf.Any parameter = 2;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 2;
  const ::google::protobuf::Any& parameter() const;
  ::google::protobuf::Any* mutable_parameter();
  ::google::protobuf::Any* release_parameter();
  void set_allocated_parameter(::google::protobuf::Any* parameter);

  // .protocol.Transaction.Contract.ContractType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Transaction_Contract_ContractType type() const;
  void set_type(::protocol::Transaction_Contract_ContractType value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Contract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr provider_;
  ::google::protobuf::internal::ArenaStringPtr contractname_;
  ::google::protobuf::Any* parameter_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction_Result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Result) */ {
 public:
  Transaction_Result();
  virtual ~Transaction_Result();

  Transaction_Result(const Transaction_Result& from);

  inline Transaction_Result& operator=(const Transaction_Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction_Result(Transaction_Result&& from) noexcept
    : Transaction_Result() {
    *this = ::std::move(from);
  }

  inline Transaction_Result& operator=(Transaction_Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction_Result& default_instance();

  static inline const Transaction_Result* internal_default_instance() {
    return reinterpret_cast<const Transaction_Result*>(
               &_Transaction_Result_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Transaction_Result* other);
  friend void swap(Transaction_Result& a, Transaction_Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction_Result* New() const PROTOBUF_FINAL { return New(NULL); }

  Transaction_Result* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transaction_Result& from);
  void MergeFrom(const Transaction_Result& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transaction_Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Transaction_Result_code code;
  static const code SUCESS =
    Transaction_Result_code_SUCESS;
  static const code FAILED =
    Transaction_Result_code_FAILED;
  static inline bool code_IsValid(int value) {
    return Transaction_Result_code_IsValid(value);
  }
  static const code code_MIN =
    Transaction_Result_code_code_MIN;
  static const code code_MAX =
    Transaction_Result_code_code_MAX;
  static const int code_ARRAYSIZE =
    Transaction_Result_code_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  code_descriptor() {
    return Transaction_Result_code_descriptor();
  }
  static inline const ::std::string& code_Name(code value) {
    return Transaction_Result_code_Name(value);
  }
  static inline bool code_Parse(const ::std::string& name,
      code* value) {
    return Transaction_Result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int64 fee = 1;
  void clear_fee();
  static const int kFeeFieldNumber = 1;
  ::google::protobuf::int64 fee() const;
  void set_fee(::google::protobuf::int64 value);

  // .protocol.Transaction.Result.code ret = 2;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::protocol::Transaction_Result_code ret() const;
  void set_ret(::protocol::Transaction_Result_code value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Result)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 fee_;
  int ret_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction_raw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.raw) */ {
 public:
  Transaction_raw();
  virtual ~Transaction_raw();

  Transaction_raw(const Transaction_raw& from);

  inline Transaction_raw& operator=(const Transaction_raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction_raw(Transaction_raw&& from) noexcept
    : Transaction_raw() {
    *this = ::std::move(from);
  }

  inline Transaction_raw& operator=(Transaction_raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction_raw& default_instance();

  static inline const Transaction_raw* internal_default_instance() {
    return reinterpret_cast<const Transaction_raw*>(
               &_Transaction_raw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Transaction_raw* other);
  friend void swap(Transaction_raw& a, Transaction_raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction_raw* New() const PROTOBUF_FINAL { return New(NULL); }

  Transaction_raw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transaction_raw& from);
  void MergeFrom(const Transaction_raw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transaction_raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.acuthrity auths = 9;
  int auths_size() const;
  void clear_auths();
  static const int kAuthsFieldNumber = 9;
  const ::protocol::acuthrity& auths(int index) const;
  ::protocol::acuthrity* mutable_auths(int index);
  ::protocol::acuthrity* add_auths();
  ::google::protobuf::RepeatedPtrField< ::protocol::acuthrity >*
      mutable_auths();
  const ::google::protobuf::RepeatedPtrField< ::protocol::acuthrity >&
      auths() const;

  // repeated .protocol.Transaction.Contract contract = 11;
  int contract_size() const;
  void clear_contract();
  static const int kContractFieldNumber = 11;
  const ::protocol::Transaction_Contract& contract(int index) const;
  ::protocol::Transaction_Contract* mutable_contract(int index);
  ::protocol::Transaction_Contract* add_contract();
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >*
      mutable_contract();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >&
      contract() const;

  // bytes ref_block_bytes = 1;
  void clear_ref_block_bytes();
  static const int kRefBlockBytesFieldNumber = 1;
  const ::std::string& ref_block_bytes() const;
  void set_ref_block_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_bytes(::std::string&& value);
  #endif
  void set_ref_block_bytes(const char* value);
  void set_ref_block_bytes(const void* value, size_t size);
  ::std::string* mutable_ref_block_bytes();
  ::std::string* release_ref_block_bytes();
  void set_allocated_ref_block_bytes(::std::string* ref_block_bytes);

  // bytes ref_block_hash = 4;
  void clear_ref_block_hash();
  static const int kRefBlockHashFieldNumber = 4;
  const ::std::string& ref_block_hash() const;
  void set_ref_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_hash(::std::string&& value);
  #endif
  void set_ref_block_hash(const char* value);
  void set_ref_block_hash(const void* value, size_t size);
  ::std::string* mutable_ref_block_hash();
  ::std::string* release_ref_block_hash();
  void set_allocated_ref_block_hash(::std::string* ref_block_hash);

  // bytes data = 10;
  void clear_data();
  static const int kDataFieldNumber = 10;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // bytes scripts = 12;
  void clear_scripts();
  static const int kScriptsFieldNumber = 12;
  const ::std::string& scripts() const;
  void set_scripts(const ::std::string& value);
  #if LANG_CXX11
  void set_scripts(::std::string&& value);
  #endif
  void set_scripts(const char* value);
  void set_scripts(const void* value, size_t size);
  ::std::string* mutable_scripts();
  ::std::string* release_scripts();
  void set_allocated_scripts(::std::string* scripts);

  // int64 ref_block_num = 3;
  void clear_ref_block_num();
  static const int kRefBlockNumFieldNumber = 3;
  ::google::protobuf::int64 ref_block_num() const;
  void set_ref_block_num(::google::protobuf::int64 value);

  // int64 expiration = 8;
  void clear_expiration();
  static const int kExpirationFieldNumber = 8;
  ::google::protobuf::int64 expiration() const;
  void set_expiration(::google::protobuf::int64 value);

  // int64 timestamp = 14;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 14;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction.raw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::acuthrity > auths_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract > contract_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_bytes_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_hash_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr scripts_;
  ::google::protobuf::int64 ref_block_num_;
  ::google::protobuf::int64 expiration_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const PROTOBUF_FINAL { return New(NULL); }

  Transaction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract Contract;
  typedef Transaction_Result Result;
  typedef Transaction_raw raw;

  // accessors -------------------------------------------------------

  // repeated bytes signature = 2;
  int signature_size() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature(int index) const;
  ::std::string* mutable_signature(int index);
  void set_signature(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signature(int index, ::std::string&& value);
  #endif
  void set_signature(int index, const char* value);
  void set_signature(int index, const void* value, size_t size);
  ::std::string* add_signature();
  void add_signature(const ::std::string& value);
  #if LANG_CXX11
  void add_signature(::std::string&& value);
  #endif
  void add_signature(const char* value);
  void add_signature(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signature() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signature();

  // repeated .protocol.Transaction.Result ret = 5;
  int ret_size() const;
  void clear_ret();
  static const int kRetFieldNumber = 5;
  const ::protocol::Transaction_Result& ret(int index) const;
  ::protocol::Transaction_Result* mutable_ret(int index);
  ::protocol::Transaction_Result* add_ret();
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Result >*
      mutable_ret();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Result >&
      ret() const;

  // .protocol.Transaction.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::protocol::Transaction_raw& raw_data() const;
  ::protocol::Transaction_raw* mutable_raw_data();
  ::protocol::Transaction_raw* release_raw_data();
  void set_allocated_raw_data(::protocol::Transaction_raw* raw_data);

  // @@protoc_insertion_point(class_scope:protocol.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signature_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Result > ret_;
  ::protocol::Transaction_raw* raw_data_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transactions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transactions) */ {
 public:
  Transactions();
  virtual ~Transactions();

  Transactions(const Transactions& from);

  inline Transactions& operator=(const Transactions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transactions(Transactions&& from) noexcept
    : Transactions() {
    *this = ::std::move(from);
  }

  inline Transactions& operator=(Transactions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transactions& default_instance();

  static inline const Transactions* internal_default_instance() {
    return reinterpret_cast<const Transactions*>(
               &_Transactions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Transactions* other);
  friend void swap(Transactions& a, Transactions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transactions* New() const PROTOBUF_FINAL { return New(NULL); }

  Transactions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transactions& from);
  void MergeFrom(const Transactions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transactions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Transaction transactions = 1;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 1;
  const ::protocol::Transaction& transactions(int index) const;
  ::protocol::Transaction* mutable_transactions(int index);
  ::protocol::Transaction* add_transactions();
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transactions();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:protocol.Transactions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction > transactions_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockHeader_raw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader.raw) */ {
 public:
  BlockHeader_raw();
  virtual ~BlockHeader_raw();

  BlockHeader_raw(const BlockHeader_raw& from);

  inline BlockHeader_raw& operator=(const BlockHeader_raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader_raw(BlockHeader_raw&& from) noexcept
    : BlockHeader_raw() {
    *this = ::std::move(from);
  }

  inline BlockHeader_raw& operator=(BlockHeader_raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockHeader_raw& default_instance();

  static inline const BlockHeader_raw* internal_default_instance() {
    return reinterpret_cast<const BlockHeader_raw*>(
               &_BlockHeader_raw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(BlockHeader_raw* other);
  friend void swap(BlockHeader_raw& a, BlockHeader_raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader_raw* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockHeader_raw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockHeader_raw& from);
  void MergeFrom(const BlockHeader_raw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockHeader_raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes txTrieRoot = 2;
  void clear_txtrieroot();
  static const int kTxTrieRootFieldNumber = 2;
  const ::std::string& txtrieroot() const;
  void set_txtrieroot(const ::std::string& value);
  #if LANG_CXX11
  void set_txtrieroot(::std::string&& value);
  #endif
  void set_txtrieroot(const char* value);
  void set_txtrieroot(const void* value, size_t size);
  ::std::string* mutable_txtrieroot();
  ::std::string* release_txtrieroot();
  void set_allocated_txtrieroot(::std::string* txtrieroot);

  // bytes parentHash = 3;
  void clear_parenthash();
  static const int kParentHashFieldNumber = 3;
  const ::std::string& parenthash() const;
  void set_parenthash(const ::std::string& value);
  #if LANG_CXX11
  void set_parenthash(::std::string&& value);
  #endif
  void set_parenthash(const char* value);
  void set_parenthash(const void* value, size_t size);
  ::std::string* mutable_parenthash();
  ::std::string* release_parenthash();
  void set_allocated_parenthash(::std::string* parenthash);

  // bytes witness_address = 9;
  void clear_witness_address();
  static const int kWitnessAddressFieldNumber = 9;
  const ::std::string& witness_address() const;
  void set_witness_address(const ::std::string& value);
  #if LANG_CXX11
  void set_witness_address(::std::string&& value);
  #endif
  void set_witness_address(const char* value);
  void set_witness_address(const void* value, size_t size);
  ::std::string* mutable_witness_address();
  ::std::string* release_witness_address();
  void set_allocated_witness_address(::std::string* witness_address);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 number = 7;
  void clear_number();
  static const int kNumberFieldNumber = 7;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // int64 witness_id = 8;
  void clear_witness_id();
  static const int kWitnessIdFieldNumber = 8;
  ::google::protobuf::int64 witness_id() const;
  void set_witness_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader.raw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txtrieroot_;
  ::google::protobuf::internal::ArenaStringPtr parenthash_;
  ::google::protobuf::internal::ArenaStringPtr witness_address_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 number_;
  ::google::protobuf::int64 witness_id_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader) */ {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockHeader& default_instance();

  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(BlockHeader* other);
  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BlockHeader_raw raw;

  // accessors -------------------------------------------------------

  // bytes witness_signature = 2;
  void clear_witness_signature();
  static const int kWitnessSignatureFieldNumber = 2;
  const ::std::string& witness_signature() const;
  void set_witness_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_witness_signature(::std::string&& value);
  #endif
  void set_witness_signature(const char* value);
  void set_witness_signature(const void* value, size_t size);
  ::std::string* mutable_witness_signature();
  ::std::string* release_witness_signature();
  void set_allocated_witness_signature(::std::string* witness_signature);

  // .protocol.BlockHeader.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::protocol::BlockHeader_raw& raw_data() const;
  ::protocol::BlockHeader_raw* mutable_raw_data();
  ::protocol::BlockHeader_raw* release_raw_data();
  void set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data);

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr witness_signature_;
  ::protocol::BlockHeader_raw* raw_data_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const PROTOBUF_FINAL { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Transaction transactions = 1;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 1;
  const ::protocol::Transaction& transactions(int index) const;
  ::protocol::Transaction* mutable_transactions(int index);
  ::protocol::Transaction* add_transactions();
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transactions();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
      transactions() const;

  // .protocol.BlockHeader block_header = 2;
  bool has_block_header() const;
  void clear_block_header();
  static const int kBlockHeaderFieldNumber = 2;
  const ::protocol::BlockHeader& block_header() const;
  ::protocol::BlockHeader* mutable_block_header();
  ::protocol::BlockHeader* release_block_header();
  void set_allocated_block_header(::protocol::BlockHeader* block_header);

  // @@protoc_insertion_point(class_scope:protocol.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction > transactions_;
  ::protocol::BlockHeader* block_header_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainInventory_BlockId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainInventory.BlockId) */ {
 public:
  ChainInventory_BlockId();
  virtual ~ChainInventory_BlockId();

  ChainInventory_BlockId(const ChainInventory_BlockId& from);

  inline ChainInventory_BlockId& operator=(const ChainInventory_BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChainInventory_BlockId(ChainInventory_BlockId&& from) noexcept
    : ChainInventory_BlockId() {
    *this = ::std::move(from);
  }

  inline ChainInventory_BlockId& operator=(ChainInventory_BlockId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainInventory_BlockId& default_instance();

  static inline const ChainInventory_BlockId* internal_default_instance() {
    return reinterpret_cast<const ChainInventory_BlockId*>(
               &_ChainInventory_BlockId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(ChainInventory_BlockId* other);
  friend void swap(ChainInventory_BlockId& a, ChainInventory_BlockId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChainInventory_BlockId* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainInventory_BlockId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainInventory_BlockId& from);
  void MergeFrom(const ChainInventory_BlockId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainInventory_BlockId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // int64 number = 2;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainInventory.BlockId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int64 number_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainInventory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainInventory) */ {
 public:
  ChainInventory();
  virtual ~ChainInventory();

  ChainInventory(const ChainInventory& from);

  inline ChainInventory& operator=(const ChainInventory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChainInventory(ChainInventory&& from) noexcept
    : ChainInventory() {
    *this = ::std::move(from);
  }

  inline ChainInventory& operator=(ChainInventory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainInventory& default_instance();

  static inline const ChainInventory* internal_default_instance() {
    return reinterpret_cast<const ChainInventory*>(
               &_ChainInventory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(ChainInventory* other);
  friend void swap(ChainInventory& a, ChainInventory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChainInventory* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainInventory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainInventory& from);
  void MergeFrom(const ChainInventory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainInventory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChainInventory_BlockId BlockId;

  // accessors -------------------------------------------------------

  // repeated .protocol.ChainInventory.BlockId ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::protocol::ChainInventory_BlockId& ids(int index) const;
  ::protocol::ChainInventory_BlockId* mutable_ids(int index);
  ::protocol::ChainInventory_BlockId* add_ids();
  ::google::protobuf::RepeatedPtrField< ::protocol::ChainInventory_BlockId >*
      mutable_ids();
  const ::google::protobuf::RepeatedPtrField< ::protocol::ChainInventory_BlockId >&
      ids() const;

  // int64 remain_num = 2;
  void clear_remain_num();
  static const int kRemainNumFieldNumber = 2;
  ::google::protobuf::int64 remain_num() const;
  void set_remain_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainInventory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::ChainInventory_BlockId > ids_;
  ::google::protobuf::int64 remain_num_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockInventory_BlockId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockInventory.BlockId) */ {
 public:
  BlockInventory_BlockId();
  virtual ~BlockInventory_BlockId();

  BlockInventory_BlockId(const BlockInventory_BlockId& from);

  inline BlockInventory_BlockId& operator=(const BlockInventory_BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockInventory_BlockId(BlockInventory_BlockId&& from) noexcept
    : BlockInventory_BlockId() {
    *this = ::std::move(from);
  }

  inline BlockInventory_BlockId& operator=(BlockInventory_BlockId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInventory_BlockId& default_instance();

  static inline const BlockInventory_BlockId* internal_default_instance() {
    return reinterpret_cast<const BlockInventory_BlockId*>(
               &_BlockInventory_BlockId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(BlockInventory_BlockId* other);
  friend void swap(BlockInventory_BlockId& a, BlockInventory_BlockId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockInventory_BlockId* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockInventory_BlockId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockInventory_BlockId& from);
  void MergeFrom(const BlockInventory_BlockId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockInventory_BlockId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // int64 number = 2;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.BlockInventory.BlockId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int64 number_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockInventory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockInventory) */ {
 public:
  BlockInventory();
  virtual ~BlockInventory();

  BlockInventory(const BlockInventory& from);

  inline BlockInventory& operator=(const BlockInventory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockInventory(BlockInventory&& from) noexcept
    : BlockInventory() {
    *this = ::std::move(from);
  }

  inline BlockInventory& operator=(BlockInventory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInventory& default_instance();

  static inline const BlockInventory* internal_default_instance() {
    return reinterpret_cast<const BlockInventory*>(
               &_BlockInventory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(BlockInventory* other);
  friend void swap(BlockInventory& a, BlockInventory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockInventory* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockInventory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockInventory& from);
  void MergeFrom(const BlockInventory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockInventory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BlockInventory_BlockId BlockId;

  typedef BlockInventory_Type Type;
  static const Type SYNC =
    BlockInventory_Type_SYNC;
  static const Type ADVTISE =
    BlockInventory_Type_ADVTISE;
  static const Type FETCH =
    BlockInventory_Type_FETCH;
  static inline bool Type_IsValid(int value) {
    return BlockInventory_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BlockInventory_Type_Type_MIN;
  static const Type Type_MAX =
    BlockInventory_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BlockInventory_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return BlockInventory_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return BlockInventory_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return BlockInventory_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .protocol.BlockInventory.BlockId ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  const ::protocol::BlockInventory_BlockId& ids(int index) const;
  ::protocol::BlockInventory_BlockId* mutable_ids(int index);
  ::protocol::BlockInventory_BlockId* add_ids();
  ::google::protobuf::RepeatedPtrField< ::protocol::BlockInventory_BlockId >*
      mutable_ids();
  const ::google::protobuf::RepeatedPtrField< ::protocol::BlockInventory_BlockId >&
      ids() const;

  // .protocol.BlockInventory.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::protocol::BlockInventory_Type type() const;
  void set_type(::protocol::BlockInventory_Type value);

  // @@protoc_insertion_point(class_scope:protocol.BlockInventory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::BlockInventory_BlockId > ids_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Inventory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Inventory) */ {
 public:
  Inventory();
  virtual ~Inventory();

  Inventory(const Inventory& from);

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(Inventory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Inventory& default_instance();

  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Inventory* other);
  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Inventory* New() const PROTOBUF_FINAL { return New(NULL); }

  Inventory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Inventory& from);
  void MergeFrom(const Inventory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Inventory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Inventory_InventoryType InventoryType;
  static const InventoryType TRX =
    Inventory_InventoryType_TRX;
  static const InventoryType BLOCK =
    Inventory_InventoryType_BLOCK;
  static inline bool InventoryType_IsValid(int value) {
    return Inventory_InventoryType_IsValid(value);
  }
  static const InventoryType InventoryType_MIN =
    Inventory_InventoryType_InventoryType_MIN;
  static const InventoryType InventoryType_MAX =
    Inventory_InventoryType_InventoryType_MAX;
  static const int InventoryType_ARRAYSIZE =
    Inventory_InventoryType_InventoryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InventoryType_descriptor() {
    return Inventory_InventoryType_descriptor();
  }
  static inline const ::std::string& InventoryType_Name(InventoryType value) {
    return Inventory_InventoryType_Name(value);
  }
  static inline bool InventoryType_Parse(const ::std::string& name,
      InventoryType* value) {
    return Inventory_InventoryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes ids = 2;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 2;
  const ::std::string& ids(int index) const;
  ::std::string* mutable_ids(int index);
  void set_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ids(int index, ::std::string&& value);
  #endif
  void set_ids(int index, const char* value);
  void set_ids(int index, const void* value, size_t size);
  ::std::string* add_ids();
  void add_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_ids(::std::string&& value);
  #endif
  void add_ids(const char* value);
  void add_ids(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ids();

  // .protocol.Inventory.InventoryType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Inventory_InventoryType type() const;
  void set_type(::protocol::Inventory_InventoryType value);

  // @@protoc_insertion_point(class_scope:protocol.Inventory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ids_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Items : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Items) */ {
 public:
  Items();
  virtual ~Items();

  Items(const Items& from);

  inline Items& operator=(const Items& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Items(Items&& from) noexcept
    : Items() {
    *this = ::std::move(from);
  }

  inline Items& operator=(Items&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Items& default_instance();

  static inline const Items* internal_default_instance() {
    return reinterpret_cast<const Items*>(
               &_Items_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(Items* other);
  friend void swap(Items& a, Items& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Items* New() const PROTOBUF_FINAL { return New(NULL); }

  Items* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Items& from);
  void MergeFrom(const Items& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Items* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Items_ItemType ItemType;
  static const ItemType ERR =
    Items_ItemType_ERR;
  static const ItemType TRX =
    Items_ItemType_TRX;
  static const ItemType BLOCK =
    Items_ItemType_BLOCK;
  static const ItemType BLOCKHEADER =
    Items_ItemType_BLOCKHEADER;
  static inline bool ItemType_IsValid(int value) {
    return Items_ItemType_IsValid(value);
  }
  static const ItemType ItemType_MIN =
    Items_ItemType_ItemType_MIN;
  static const ItemType ItemType_MAX =
    Items_ItemType_ItemType_MAX;
  static const int ItemType_ARRAYSIZE =
    Items_ItemType_ItemType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ItemType_descriptor() {
    return Items_ItemType_descriptor();
  }
  static inline const ::std::string& ItemType_Name(ItemType value) {
    return Items_ItemType_Name(value);
  }
  static inline bool ItemType_Parse(const ::std::string& name,
      ItemType* value) {
    return Items_ItemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .protocol.Block blocks = 2;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 2;
  const ::protocol::Block& blocks(int index) const;
  ::protocol::Block* mutable_blocks(int index);
  ::protocol::Block* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::protocol::Block >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Block >&
      blocks() const;

  // repeated .protocol.BlockHeader block_headers = 3;
  int block_headers_size() const;
  void clear_block_headers();
  static const int kBlockHeadersFieldNumber = 3;
  const ::protocol::BlockHeader& block_headers(int index) const;
  ::protocol::BlockHeader* mutable_block_headers(int index);
  ::protocol::BlockHeader* add_block_headers();
  ::google::protobuf::RepeatedPtrField< ::protocol::BlockHeader >*
      mutable_block_headers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::BlockHeader >&
      block_headers() const;

  // repeated .protocol.Transaction transactions = 4;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 4;
  const ::protocol::Transaction& transactions(int index) const;
  ::protocol::Transaction* mutable_transactions(int index);
  ::protocol::Transaction* add_transactions();
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transactions();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
      transactions() const;

  // .protocol.Items.ItemType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Items_ItemType type() const;
  void set_type(::protocol::Items_ItemType value);

  // @@protoc_insertion_point(class_scope:protocol.Items)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Block > blocks_;
  ::google::protobuf::RepeatedPtrField< ::protocol::BlockHeader > block_headers_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction > transactions_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DynamicProperties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.DynamicProperties) */ {
 public:
  DynamicProperties();
  virtual ~DynamicProperties();

  DynamicProperties(const DynamicProperties& from);

  inline DynamicProperties& operator=(const DynamicProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicProperties(DynamicProperties&& from) noexcept
    : DynamicProperties() {
    *this = ::std::move(from);
  }

  inline DynamicProperties& operator=(DynamicProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicProperties& default_instance();

  static inline const DynamicProperties* internal_default_instance() {
    return reinterpret_cast<const DynamicProperties*>(
               &_DynamicProperties_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(DynamicProperties* other);
  friend void swap(DynamicProperties& a, DynamicProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicProperties* New() const PROTOBUF_FINAL { return New(NULL); }

  DynamicProperties* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DynamicProperties& from);
  void MergeFrom(const DynamicProperties& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DynamicProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 last_solidity_block_num = 1;
  void clear_last_solidity_block_num();
  static const int kLastSolidityBlockNumFieldNumber = 1;
  ::google::protobuf::int64 last_solidity_block_num() const;
  void set_last_solidity_block_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.DynamicProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 last_solidity_block_num_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DisconnectMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.DisconnectMessage) */ {
 public:
  DisconnectMessage();
  virtual ~DisconnectMessage();

  DisconnectMessage(const DisconnectMessage& from);

  inline DisconnectMessage& operator=(const DisconnectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DisconnectMessage(DisconnectMessage&& from) noexcept
    : DisconnectMessage() {
    *this = ::std::move(from);
  }

  inline DisconnectMessage& operator=(DisconnectMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DisconnectMessage& default_instance();

  static inline const DisconnectMessage* internal_default_instance() {
    return reinterpret_cast<const DisconnectMessage*>(
               &_DisconnectMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(DisconnectMessage* other);
  friend void swap(DisconnectMessage& a, DisconnectMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DisconnectMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  DisconnectMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DisconnectMessage& from);
  void MergeFrom(const DisconnectMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DisconnectMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .protocol.ReasonCode reason = 1;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  ::protocol::ReasonCode reason() const;
  void set_reason(::protocol::ReasonCode value);

  // @@protoc_insertion_point(class_scope:protocol.DisconnectMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int reason_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HelloMessage_BlockId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.HelloMessage.BlockId) */ {
 public:
  HelloMessage_BlockId();
  virtual ~HelloMessage_BlockId();

  HelloMessage_BlockId(const HelloMessage_BlockId& from);

  inline HelloMessage_BlockId& operator=(const HelloMessage_BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloMessage_BlockId(HelloMessage_BlockId&& from) noexcept
    : HelloMessage_BlockId() {
    *this = ::std::move(from);
  }

  inline HelloMessage_BlockId& operator=(HelloMessage_BlockId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloMessage_BlockId& default_instance();

  static inline const HelloMessage_BlockId* internal_default_instance() {
    return reinterpret_cast<const HelloMessage_BlockId*>(
               &_HelloMessage_BlockId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(HelloMessage_BlockId* other);
  friend void swap(HelloMessage_BlockId& a, HelloMessage_BlockId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloMessage_BlockId* New() const PROTOBUF_FINAL { return New(NULL); }

  HelloMessage_BlockId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HelloMessage_BlockId& from);
  void MergeFrom(const HelloMessage_BlockId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HelloMessage_BlockId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // int64 number = 2;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.HelloMessage.BlockId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int64 number_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HelloMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.HelloMessage) */ {
 public:
  HelloMessage();
  virtual ~HelloMessage();

  HelloMessage(const HelloMessage& from);

  inline HelloMessage& operator=(const HelloMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloMessage(HelloMessage&& from) noexcept
    : HelloMessage() {
    *this = ::std::move(from);
  }

  inline HelloMessage& operator=(HelloMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloMessage& default_instance();

  static inline const HelloMessage* internal_default_instance() {
    return reinterpret_cast<const HelloMessage*>(
               &_HelloMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(HelloMessage* other);
  friend void swap(HelloMessage& a, HelloMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  HelloMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HelloMessage& from);
  void MergeFrom(const HelloMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HelloMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef HelloMessage_BlockId BlockId;

  // accessors -------------------------------------------------------

  // .protocol.Endpoint from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::protocol::Endpoint& from() const;
  ::protocol::Endpoint* mutable_from();
  ::protocol::Endpoint* release_from();
  void set_allocated_from(::protocol::Endpoint* from);

  // .protocol.HelloMessage.BlockId genesisBlockId = 4;
  bool has_genesisblockid() const;
  void clear_genesisblockid();
  static const int kGenesisBlockIdFieldNumber = 4;
  const ::protocol::HelloMessage_BlockId& genesisblockid() const;
  ::protocol::HelloMessage_BlockId* mutable_genesisblockid();
  ::protocol::HelloMessage_BlockId* release_genesisblockid();
  void set_allocated_genesisblockid(::protocol::HelloMessage_BlockId* genesisblockid);

  // .protocol.HelloMessage.BlockId solidBlockId = 5;
  bool has_solidblockid() const;
  void clear_solidblockid();
  static const int kSolidBlockIdFieldNumber = 5;
  const ::protocol::HelloMessage_BlockId& solidblockid() const;
  ::protocol::HelloMessage_BlockId* mutable_solidblockid();
  ::protocol::HelloMessage_BlockId* release_solidblockid();
  void set_allocated_solidblockid(::protocol::HelloMessage_BlockId* solidblockid);

  // .protocol.HelloMessage.BlockId headBlockId = 6;
  bool has_headblockid() const;
  void clear_headblockid();
  static const int kHeadBlockIdFieldNumber = 6;
  const ::protocol::HelloMessage_BlockId& headblockid() const;
  ::protocol::HelloMessage_BlockId* mutable_headblockid();
  ::protocol::HelloMessage_BlockId* release_headblockid();
  void set_allocated_headblockid(::protocol::HelloMessage_BlockId* headblockid);

  // int64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.HelloMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protocol::Endpoint* from_;
  ::protocol::HelloMessage_BlockId* genesisblockid_;
  ::protocol::HelloMessage_BlockId* solidblockid_;
  ::protocol::HelloMessage_BlockId* headblockid_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 version_;
  mutable int _cached_size_;
  friend struct protobuf_core_2fTron_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccountId

// bytes name = 1;
inline void AccountId::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountId::name() const {
  // @@protoc_insertion_point(field_get:protocol.AccountId.name)
  return name_.GetNoArena();
}
inline void AccountId::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.AccountId.name)
}
#if LANG_CXX11
inline void AccountId::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.AccountId.name)
}
#endif
inline void AccountId::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.AccountId.name)
}
inline void AccountId::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.AccountId.name)
}
inline ::std::string* AccountId::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.AccountId.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountId::release_name() {
  // @@protoc_insertion_point(field_release:protocol.AccountId.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountId::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountId.name)
}

// bytes address = 2;
inline void AccountId::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountId::address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountId.address)
  return address_.GetNoArena();
}
inline void AccountId::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.AccountId.address)
}
#if LANG_CXX11
inline void AccountId::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.AccountId.address)
}
#endif
inline void AccountId::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.AccountId.address)
}
inline void AccountId::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.AccountId.address)
}
inline ::std::string* AccountId::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.AccountId.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountId::release_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountId.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountId::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountId.address)
}

// -------------------------------------------------------------------

// Vote

// bytes vote_address = 1;
inline void Vote::clear_vote_address() {
  vote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Vote::vote_address() const {
  // @@protoc_insertion_point(field_get:protocol.Vote.vote_address)
  return vote_address_.GetNoArena();
}
inline void Vote::set_vote_address(const ::std::string& value) {
  
  vote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Vote.vote_address)
}
#if LANG_CXX11
inline void Vote::set_vote_address(::std::string&& value) {
  
  vote_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Vote.vote_address)
}
#endif
inline void Vote::set_vote_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Vote.vote_address)
}
inline void Vote::set_vote_address(const void* value, size_t size) {
  
  vote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Vote.vote_address)
}
inline ::std::string* Vote::mutable_vote_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Vote.vote_address)
  return vote_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vote::release_vote_address() {
  // @@protoc_insertion_point(field_release:protocol.Vote.vote_address)
  
  return vote_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vote::set_allocated_vote_address(::std::string* vote_address) {
  if (vote_address != NULL) {
    
  } else {
    
  }
  vote_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vote_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Vote.vote_address)
}

// int64 vote_count = 2;
inline void Vote::clear_vote_count() {
  vote_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Vote::vote_count() const {
  // @@protoc_insertion_point(field_get:protocol.Vote.vote_count)
  return vote_count_;
}
inline void Vote::set_vote_count(::google::protobuf::int64 value) {
  
  vote_count_ = value;
  // @@protoc_insertion_point(field_set:protocol.Vote.vote_count)
}

// -------------------------------------------------------------------

// Account_Frozen

// int64 frozen_balance = 1;
inline void Account_Frozen::clear_frozen_balance() {
  frozen_balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account_Frozen::frozen_balance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.Frozen.frozen_balance)
  return frozen_balance_;
}
inline void Account_Frozen::set_frozen_balance(::google::protobuf::int64 value) {
  
  frozen_balance_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.Frozen.frozen_balance)
}

// int64 expire_time = 2;
inline void Account_Frozen::clear_expire_time() {
  expire_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account_Frozen::expire_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.Frozen.expire_time)
  return expire_time_;
}
inline void Account_Frozen::set_expire_time(::google::protobuf::int64 value) {
  
  expire_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.Frozen.expire_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Account

// bytes account_name = 1;
inline void Account::clear_account_name() {
  account_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::account_name() const {
  // @@protoc_insertion_point(field_get:protocol.Account.account_name)
  return account_name_.GetNoArena();
}
inline void Account::set_account_name(const ::std::string& value) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.account_name)
}
#if LANG_CXX11
inline void Account::set_account_name(::std::string&& value) {
  
  account_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Account.account_name)
}
#endif
inline void Account::set_account_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.account_name)
}
inline void Account::set_account_name(const void* value, size_t size) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.account_name)
}
inline ::std::string* Account::mutable_account_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Account.account_name)
  return account_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_account_name() {
  // @@protoc_insertion_point(field_release:protocol.Account.account_name)
  
  return account_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_account_name(::std::string* account_name) {
  if (account_name != NULL) {
    
  } else {
    
  }
  account_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_name);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.account_name)
}

// .protocol.AccountType type = 2;
inline void Account::clear_type() {
  type_ = 0;
}
inline ::protocol::AccountType Account::type() const {
  // @@protoc_insertion_point(field_get:protocol.Account.type)
  return static_cast< ::protocol::AccountType >(type_);
}
inline void Account::set_type(::protocol::AccountType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.type)
}

// bytes address = 3;
inline void Account::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::address() const {
  // @@protoc_insertion_point(field_get:protocol.Account.address)
  return address_.GetNoArena();
}
inline void Account::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.address)
}
#if LANG_CXX11
inline void Account::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Account.address)
}
#endif
inline void Account::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.address)
}
inline void Account::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.address)
}
inline ::std::string* Account::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Account.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Account.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.address)
}

// int64 balance = 4;
inline void Account::clear_balance() {
  balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::balance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.balance)
  return balance_;
}
inline void Account::set_balance(::google::protobuf::int64 value) {
  
  balance_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.balance)
}

// repeated .protocol.Vote votes = 5;
inline int Account::votes_size() const {
  return votes_.size();
}
inline void Account::clear_votes() {
  votes_.Clear();
}
inline const ::protocol::Vote& Account::votes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.votes)
  return votes_.Get(index);
}
inline ::protocol::Vote* Account::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.votes)
  return votes_.Mutable(index);
}
inline ::protocol::Vote* Account::add_votes() {
  // @@protoc_insertion_point(field_add:protocol.Account.votes)
  return votes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Vote >*
Account::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.votes)
  return &votes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Vote >&
Account::votes() const {
  // @@protoc_insertion_point(field_list:protocol.Account.votes)
  return votes_;
}

// map<string, int64> asset = 6;
inline int Account::asset_size() const {
  return asset_.size();
}
inline void Account::clear_asset() {
  asset_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
Account::asset() const {
  // @@protoc_insertion_point(field_map:protocol.Account.asset)
  return asset_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
Account::mutable_asset() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.asset)
  return asset_.MutableMap();
}

// repeated .protocol.Account.Frozen frozen = 7;
inline int Account::frozen_size() const {
  return frozen_.size();
}
inline void Account::clear_frozen() {
  frozen_.Clear();
}
inline const ::protocol::Account_Frozen& Account::frozen(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.frozen)
  return frozen_.Get(index);
}
inline ::protocol::Account_Frozen* Account::mutable_frozen(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.frozen)
  return frozen_.Mutable(index);
}
inline ::protocol::Account_Frozen* Account::add_frozen() {
  // @@protoc_insertion_point(field_add:protocol.Account.frozen)
  return frozen_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >*
Account::mutable_frozen() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.frozen)
  return &frozen_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >&
Account::frozen() const {
  // @@protoc_insertion_point(field_list:protocol.Account.frozen)
  return frozen_;
}

// int64 net_usage = 8;
inline void Account::clear_net_usage() {
  net_usage_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::net_usage() const {
  // @@protoc_insertion_point(field_get:protocol.Account.net_usage)
  return net_usage_;
}
inline void Account::set_net_usage(::google::protobuf::int64 value) {
  
  net_usage_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.net_usage)
}

// int64 create_time = 9;
inline void Account::clear_create_time() {
  create_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::create_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.create_time)
  return create_time_;
}
inline void Account::set_create_time(::google::protobuf::int64 value) {
  
  create_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.create_time)
}

// int64 latest_opration_time = 10;
inline void Account::clear_latest_opration_time() {
  latest_opration_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::latest_opration_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_opration_time)
  return latest_opration_time_;
}
inline void Account::set_latest_opration_time(::google::protobuf::int64 value) {
  
  latest_opration_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.latest_opration_time)
}

// int64 allowance = 11;
inline void Account::clear_allowance() {
  allowance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::allowance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.allowance)
  return allowance_;
}
inline void Account::set_allowance(::google::protobuf::int64 value) {
  
  allowance_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.allowance)
}

// int64 latest_withdraw_time = 12;
inline void Account::clear_latest_withdraw_time() {
  latest_withdraw_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::latest_withdraw_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_withdraw_time)
  return latest_withdraw_time_;
}
inline void Account::set_latest_withdraw_time(::google::protobuf::int64 value) {
  
  latest_withdraw_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.latest_withdraw_time)
}

// bytes code = 13;
inline void Account::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::code() const {
  // @@protoc_insertion_point(field_get:protocol.Account.code)
  return code_.GetNoArena();
}
inline void Account::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.code)
}
#if LANG_CXX11
inline void Account::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Account.code)
}
#endif
inline void Account::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.code)
}
inline void Account::set_code(const void* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.code)
}
inline ::std::string* Account::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Account.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_code() {
  // @@protoc_insertion_point(field_release:protocol.Account.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.code)
}

// bool is_witness = 14;
inline void Account::clear_is_witness() {
  is_witness_ = false;
}
inline bool Account::is_witness() const {
  // @@protoc_insertion_point(field_get:protocol.Account.is_witness)
  return is_witness_;
}
inline void Account::set_is_witness(bool value) {
  
  is_witness_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.is_witness)
}

// bool is_committee = 15;
inline void Account::clear_is_committee() {
  is_committee_ = false;
}
inline bool Account::is_committee() const {
  // @@protoc_insertion_point(field_get:protocol.Account.is_committee)
  return is_committee_;
}
inline void Account::set_is_committee(bool value) {
  
  is_committee_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.is_committee)
}

// repeated .protocol.Account.Frozen frozen_supply = 16;
inline int Account::frozen_supply_size() const {
  return frozen_supply_.size();
}
inline void Account::clear_frozen_supply() {
  frozen_supply_.Clear();
}
inline const ::protocol::Account_Frozen& Account::frozen_supply(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.frozen_supply)
  return frozen_supply_.Get(index);
}
inline ::protocol::Account_Frozen* Account::mutable_frozen_supply(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.frozen_supply)
  return frozen_supply_.Mutable(index);
}
inline ::protocol::Account_Frozen* Account::add_frozen_supply() {
  // @@protoc_insertion_point(field_add:protocol.Account.frozen_supply)
  return frozen_supply_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >*
Account::mutable_frozen_supply() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.frozen_supply)
  return &frozen_supply_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Account_Frozen >&
Account::frozen_supply() const {
  // @@protoc_insertion_point(field_list:protocol.Account.frozen_supply)
  return frozen_supply_;
}

// bytes asset_issued_name = 17;
inline void Account::clear_asset_issued_name() {
  asset_issued_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::asset_issued_name() const {
  // @@protoc_insertion_point(field_get:protocol.Account.asset_issued_name)
  return asset_issued_name_.GetNoArena();
}
inline void Account::set_asset_issued_name(const ::std::string& value) {
  
  asset_issued_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.asset_issued_name)
}
#if LANG_CXX11
inline void Account::set_asset_issued_name(::std::string&& value) {
  
  asset_issued_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Account.asset_issued_name)
}
#endif
inline void Account::set_asset_issued_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_issued_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.asset_issued_name)
}
inline void Account::set_asset_issued_name(const void* value, size_t size) {
  
  asset_issued_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.asset_issued_name)
}
inline ::std::string* Account::mutable_asset_issued_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Account.asset_issued_name)
  return asset_issued_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_asset_issued_name() {
  // @@protoc_insertion_point(field_release:protocol.Account.asset_issued_name)
  
  return asset_issued_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_asset_issued_name(::std::string* asset_issued_name) {
  if (asset_issued_name != NULL) {
    
  } else {
    
  }
  asset_issued_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_issued_name);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.asset_issued_name)
}

// map<string, int64> latest_asset_operation_time = 18;
inline int Account::latest_asset_operation_time_size() const {
  return latest_asset_operation_time_.size();
}
inline void Account::clear_latest_asset_operation_time() {
  latest_asset_operation_time_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
Account::latest_asset_operation_time() const {
  // @@protoc_insertion_point(field_map:protocol.Account.latest_asset_operation_time)
  return latest_asset_operation_time_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
Account::mutable_latest_asset_operation_time() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.latest_asset_operation_time)
  return latest_asset_operation_time_.MutableMap();
}

// int64 free_net_usage = 19;
inline void Account::clear_free_net_usage() {
  free_net_usage_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::free_net_usage() const {
  // @@protoc_insertion_point(field_get:protocol.Account.free_net_usage)
  return free_net_usage_;
}
inline void Account::set_free_net_usage(::google::protobuf::int64 value) {
  
  free_net_usage_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.free_net_usage)
}

// map<string, int64> free_asset_net_usage = 20;
inline int Account::free_asset_net_usage_size() const {
  return free_asset_net_usage_.size();
}
inline void Account::clear_free_asset_net_usage() {
  free_asset_net_usage_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
Account::free_asset_net_usage() const {
  // @@protoc_insertion_point(field_map:protocol.Account.free_asset_net_usage)
  return free_asset_net_usage_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
Account::mutable_free_asset_net_usage() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.free_asset_net_usage)
  return free_asset_net_usage_.MutableMap();
}

// int64 latest_consume_time = 21;
inline void Account::clear_latest_consume_time() {
  latest_consume_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::latest_consume_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_consume_time)
  return latest_consume_time_;
}
inline void Account::set_latest_consume_time(::google::protobuf::int64 value) {
  
  latest_consume_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.latest_consume_time)
}

// int64 latest_consume_free_time = 22;
inline void Account::clear_latest_consume_free_time() {
  latest_consume_free_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::latest_consume_free_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_consume_free_time)
  return latest_consume_free_time_;
}
inline void Account::set_latest_consume_free_time(::google::protobuf::int64 value) {
  
  latest_consume_free_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.latest_consume_free_time)
}

// -------------------------------------------------------------------

// acuthrity

// .protocol.AccountId account = 1;
inline bool acuthrity::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void acuthrity::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) delete account_;
  account_ = NULL;
}
inline const ::protocol::AccountId& acuthrity::account() const {
  const ::protocol::AccountId* p = account_;
  // @@protoc_insertion_point(field_get:protocol.acuthrity.account)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::AccountId*>(
      &::protocol::_AccountId_default_instance_);
}
inline ::protocol::AccountId* acuthrity::mutable_account() {
  
  if (account_ == NULL) {
    account_ = new ::protocol::AccountId;
  }
  // @@protoc_insertion_point(field_mutable:protocol.acuthrity.account)
  return account_;
}
inline ::protocol::AccountId* acuthrity::release_account() {
  // @@protoc_insertion_point(field_release:protocol.acuthrity.account)
  
  ::protocol::AccountId* temp = account_;
  account_ = NULL;
  return temp;
}
inline void acuthrity::set_allocated_account(::protocol::AccountId* account) {
  delete account_;
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.acuthrity.account)
}

// bytes permission_name = 2;
inline void acuthrity::clear_permission_name() {
  permission_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& acuthrity::permission_name() const {
  // @@protoc_insertion_point(field_get:protocol.acuthrity.permission_name)
  return permission_name_.GetNoArena();
}
inline void acuthrity::set_permission_name(const ::std::string& value) {
  
  permission_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.acuthrity.permission_name)
}
#if LANG_CXX11
inline void acuthrity::set_permission_name(::std::string&& value) {
  
  permission_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.acuthrity.permission_name)
}
#endif
inline void acuthrity::set_permission_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  permission_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.acuthrity.permission_name)
}
inline void acuthrity::set_permission_name(const void* value, size_t size) {
  
  permission_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.acuthrity.permission_name)
}
inline ::std::string* acuthrity::mutable_permission_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.acuthrity.permission_name)
  return permission_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* acuthrity::release_permission_name() {
  // @@protoc_insertion_point(field_release:protocol.acuthrity.permission_name)
  
  return permission_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void acuthrity::set_allocated_permission_name(::std::string* permission_name) {
  if (permission_name != NULL) {
    
  } else {
    
  }
  permission_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), permission_name);
  // @@protoc_insertion_point(field_set_allocated:protocol.acuthrity.permission_name)
}

// -------------------------------------------------------------------

// permision

// .protocol.AccountId account = 1;
inline bool permision::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void permision::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) delete account_;
  account_ = NULL;
}
inline const ::protocol::AccountId& permision::account() const {
  const ::protocol::AccountId* p = account_;
  // @@protoc_insertion_point(field_get:protocol.permision.account)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::AccountId*>(
      &::protocol::_AccountId_default_instance_);
}
inline ::protocol::AccountId* permision::mutable_account() {
  
  if (account_ == NULL) {
    account_ = new ::protocol::AccountId;
  }
  // @@protoc_insertion_point(field_mutable:protocol.permision.account)
  return account_;
}
inline ::protocol::AccountId* permision::release_account() {
  // @@protoc_insertion_point(field_release:protocol.permision.account)
  
  ::protocol::AccountId* temp = account_;
  account_ = NULL;
  return temp;
}
inline void permision::set_allocated_account(::protocol::AccountId* account) {
  delete account_;
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.permision.account)
}

// -------------------------------------------------------------------

// Witness

// bytes address = 1;
inline void Witness::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Witness::address() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.address)
  return address_.GetNoArena();
}
inline void Witness::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Witness.address)
}
#if LANG_CXX11
inline void Witness::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Witness.address)
}
#endif
inline void Witness::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Witness.address)
}
inline void Witness::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Witness.address)
}
inline ::std::string* Witness::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Witness.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Witness::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Witness.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Witness.address)
}

// int64 voteCount = 2;
inline void Witness::clear_votecount() {
  votecount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Witness::votecount() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.voteCount)
  return votecount_;
}
inline void Witness::set_votecount(::google::protobuf::int64 value) {
  
  votecount_ = value;
  // @@protoc_insertion_point(field_set:protocol.Witness.voteCount)
}

// bytes pubKey = 3;
inline void Witness::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Witness::pubkey() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.pubKey)
  return pubkey_.GetNoArena();
}
inline void Witness::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Witness.pubKey)
}
#if LANG_CXX11
inline void Witness::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Witness.pubKey)
}
#endif
inline void Witness::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Witness.pubKey)
}
inline void Witness::set_pubkey(const void* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Witness.pubKey)
}
inline ::std::string* Witness::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Witness.pubKey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Witness::release_pubkey() {
  // @@protoc_insertion_point(field_release:protocol.Witness.pubKey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:protocol.Witness.pubKey)
}

// string url = 4;
inline void Witness::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Witness::url() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.url)
  return url_.GetNoArena();
}
inline void Witness::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Witness.url)
}
#if LANG_CXX11
inline void Witness::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Witness.url)
}
#endif
inline void Witness::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Witness.url)
}
inline void Witness::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Witness.url)
}
inline ::std::string* Witness::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Witness.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Witness::release_url() {
  // @@protoc_insertion_point(field_release:protocol.Witness.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:protocol.Witness.url)
}

// int64 totalProduced = 5;
inline void Witness::clear_totalproduced() {
  totalproduced_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Witness::totalproduced() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.totalProduced)
  return totalproduced_;
}
inline void Witness::set_totalproduced(::google::protobuf::int64 value) {
  
  totalproduced_ = value;
  // @@protoc_insertion_point(field_set:protocol.Witness.totalProduced)
}

// int64 totalMissed = 6;
inline void Witness::clear_totalmissed() {
  totalmissed_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Witness::totalmissed() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.totalMissed)
  return totalmissed_;
}
inline void Witness::set_totalmissed(::google::protobuf::int64 value) {
  
  totalmissed_ = value;
  // @@protoc_insertion_point(field_set:protocol.Witness.totalMissed)
}

// int64 latestBlockNum = 7;
inline void Witness::clear_latestblocknum() {
  latestblocknum_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Witness::latestblocknum() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.latestBlockNum)
  return latestblocknum_;
}
inline void Witness::set_latestblocknum(::google::protobuf::int64 value) {
  
  latestblocknum_ = value;
  // @@protoc_insertion_point(field_set:protocol.Witness.latestBlockNum)
}

// int64 latestSlotNum = 8;
inline void Witness::clear_latestslotnum() {
  latestslotnum_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Witness::latestslotnum() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.latestSlotNum)
  return latestslotnum_;
}
inline void Witness::set_latestslotnum(::google::protobuf::int64 value) {
  
  latestslotnum_ = value;
  // @@protoc_insertion_point(field_set:protocol.Witness.latestSlotNum)
}

// bool isJobs = 9;
inline void Witness::clear_isjobs() {
  isjobs_ = false;
}
inline bool Witness::isjobs() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.isJobs)
  return isjobs_;
}
inline void Witness::set_isjobs(bool value) {
  
  isjobs_ = value;
  // @@protoc_insertion_point(field_set:protocol.Witness.isJobs)
}

// -------------------------------------------------------------------

// Votes

// bytes address = 1;
inline void Votes::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Votes::address() const {
  // @@protoc_insertion_point(field_get:protocol.Votes.address)
  return address_.GetNoArena();
}
inline void Votes::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Votes.address)
}
#if LANG_CXX11
inline void Votes::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Votes.address)
}
#endif
inline void Votes::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Votes.address)
}
inline void Votes::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Votes.address)
}
inline ::std::string* Votes::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Votes.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Votes::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Votes.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Votes::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Votes.address)
}

// repeated .protocol.Vote old_votes = 2;
inline int Votes::old_votes_size() const {
  return old_votes_.size();
}
inline void Votes::clear_old_votes() {
  old_votes_.Clear();
}
inline const ::protocol::Vote& Votes::old_votes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Votes.old_votes)
  return old_votes_.Get(index);
}
inline ::protocol::Vote* Votes::mutable_old_votes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Votes.old_votes)
  return old_votes_.Mutable(index);
}
inline ::protocol::Vote* Votes::add_old_votes() {
  // @@protoc_insertion_point(field_add:protocol.Votes.old_votes)
  return old_votes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Vote >*
Votes::mutable_old_votes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Votes.old_votes)
  return &old_votes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Vote >&
Votes::old_votes() const {
  // @@protoc_insertion_point(field_list:protocol.Votes.old_votes)
  return old_votes_;
}

// repeated .protocol.Vote new_votes = 3;
inline int Votes::new_votes_size() const {
  return new_votes_.size();
}
inline void Votes::clear_new_votes() {
  new_votes_.Clear();
}
inline const ::protocol::Vote& Votes::new_votes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Votes.new_votes)
  return new_votes_.Get(index);
}
inline ::protocol::Vote* Votes::mutable_new_votes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Votes.new_votes)
  return new_votes_.Mutable(index);
}
inline ::protocol::Vote* Votes::add_new_votes() {
  // @@protoc_insertion_point(field_add:protocol.Votes.new_votes)
  return new_votes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Vote >*
Votes::mutable_new_votes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Votes.new_votes)
  return &new_votes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Vote >&
Votes::new_votes() const {
  // @@protoc_insertion_point(field_list:protocol.Votes.new_votes)
  return new_votes_;
}

// -------------------------------------------------------------------

// TXOutput

// int64 value = 1;
inline void TXOutput::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TXOutput::value() const {
  // @@protoc_insertion_point(field_get:protocol.TXOutput.value)
  return value_;
}
inline void TXOutput::set_value(::google::protobuf::int64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:protocol.TXOutput.value)
}

// bytes pubKeyHash = 2;
inline void TXOutput::clear_pubkeyhash() {
  pubkeyhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TXOutput::pubkeyhash() const {
  // @@protoc_insertion_point(field_get:protocol.TXOutput.pubKeyHash)
  return pubkeyhash_.GetNoArena();
}
inline void TXOutput::set_pubkeyhash(const ::std::string& value) {
  
  pubkeyhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TXOutput.pubKeyHash)
}
#if LANG_CXX11
inline void TXOutput::set_pubkeyhash(::std::string&& value) {
  
  pubkeyhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TXOutput.pubKeyHash)
}
#endif
inline void TXOutput::set_pubkeyhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkeyhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TXOutput.pubKeyHash)
}
inline void TXOutput::set_pubkeyhash(const void* value, size_t size) {
  
  pubkeyhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TXOutput.pubKeyHash)
}
inline ::std::string* TXOutput::mutable_pubkeyhash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TXOutput.pubKeyHash)
  return pubkeyhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TXOutput::release_pubkeyhash() {
  // @@protoc_insertion_point(field_release:protocol.TXOutput.pubKeyHash)
  
  return pubkeyhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TXOutput::set_allocated_pubkeyhash(::std::string* pubkeyhash) {
  if (pubkeyhash != NULL) {
    
  } else {
    
  }
  pubkeyhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkeyhash);
  // @@protoc_insertion_point(field_set_allocated:protocol.TXOutput.pubKeyHash)
}

// -------------------------------------------------------------------

// TXInput_raw

// bytes txID = 1;
inline void TXInput_raw::clear_txid() {
  txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TXInput_raw::txid() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw.txID)
  return txid_.GetNoArena();
}
inline void TXInput_raw::set_txid(const ::std::string& value) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TXInput.raw.txID)
}
#if LANG_CXX11
inline void TXInput_raw::set_txid(::std::string&& value) {
  
  txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TXInput.raw.txID)
}
#endif
inline void TXInput_raw::set_txid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TXInput.raw.txID)
}
inline void TXInput_raw::set_txid(const void* value, size_t size) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TXInput.raw.txID)
}
inline ::std::string* TXInput_raw::mutable_txid() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.raw.txID)
  return txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TXInput_raw::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.raw.txID)
  
  return txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TXInput_raw::set_allocated_txid(::std::string* txid) {
  if (txid != NULL) {
    
  } else {
    
  }
  txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txid);
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.raw.txID)
}

// int64 vout = 2;
inline void TXInput_raw::clear_vout() {
  vout_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TXInput_raw::vout() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw.vout)
  return vout_;
}
inline void TXInput_raw::set_vout(::google::protobuf::int64 value) {
  
  vout_ = value;
  // @@protoc_insertion_point(field_set:protocol.TXInput.raw.vout)
}

// bytes pubKey = 3;
inline void TXInput_raw::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TXInput_raw::pubkey() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw.pubKey)
  return pubkey_.GetNoArena();
}
inline void TXInput_raw::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TXInput.raw.pubKey)
}
#if LANG_CXX11
inline void TXInput_raw::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TXInput.raw.pubKey)
}
#endif
inline void TXInput_raw::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TXInput.raw.pubKey)
}
inline void TXInput_raw::set_pubkey(const void* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TXInput.raw.pubKey)
}
inline ::std::string* TXInput_raw::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.raw.pubKey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TXInput_raw::release_pubkey() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.raw.pubKey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TXInput_raw::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.raw.pubKey)
}

// -------------------------------------------------------------------

// TXInput

// .protocol.TXInput.raw raw_data = 1;
inline bool TXInput::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != NULL;
}
inline void TXInput::clear_raw_data() {
  if (GetArenaNoVirtual() == NULL && raw_data_ != NULL) delete raw_data_;
  raw_data_ = NULL;
}
inline const ::protocol::TXInput_raw& TXInput::raw_data() const {
  const ::protocol::TXInput_raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw_data)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::TXInput_raw*>(
      &::protocol::_TXInput_raw_default_instance_);
}
inline ::protocol::TXInput_raw* TXInput::mutable_raw_data() {
  
  if (raw_data_ == NULL) {
    raw_data_ = new ::protocol::TXInput_raw;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.raw_data)
  return raw_data_;
}
inline ::protocol::TXInput_raw* TXInput::release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.raw_data)
  
  ::protocol::TXInput_raw* temp = raw_data_;
  raw_data_ = NULL;
  return temp;
}
inline void TXInput::set_allocated_raw_data(::protocol::TXInput_raw* raw_data) {
  delete raw_data_;
  raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.raw_data)
}

// bytes signature = 4;
inline void TXInput::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TXInput::signature() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.signature)
  return signature_.GetNoArena();
}
inline void TXInput::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TXInput.signature)
}
#if LANG_CXX11
inline void TXInput::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TXInput.signature)
}
#endif
inline void TXInput::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TXInput.signature)
}
inline void TXInput::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TXInput.signature)
}
inline ::std::string* TXInput::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TXInput::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TXInput::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.signature)
}

// -------------------------------------------------------------------

// TXOutputs

// repeated .protocol.TXOutput outputs = 1;
inline int TXOutputs::outputs_size() const {
  return outputs_.size();
}
inline void TXOutputs::clear_outputs() {
  outputs_.Clear();
}
inline const ::protocol::TXOutput& TXOutputs::outputs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TXOutputs.outputs)
  return outputs_.Get(index);
}
inline ::protocol::TXOutput* TXOutputs::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TXOutputs.outputs)
  return outputs_.Mutable(index);
}
inline ::protocol::TXOutput* TXOutputs::add_outputs() {
  // @@protoc_insertion_point(field_add:protocol.TXOutputs.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TXOutput >*
TXOutputs::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TXOutputs.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TXOutput >&
TXOutputs::outputs() const {
  // @@protoc_insertion_point(field_list:protocol.TXOutputs.outputs)
  return outputs_;
}

// -------------------------------------------------------------------

// Transaction_Contract

// .protocol.Transaction.Contract.ContractType type = 1;
inline void Transaction_Contract::clear_type() {
  type_ = 0;
}
inline ::protocol::Transaction_Contract_ContractType Transaction_Contract::type() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.type)
  return static_cast< ::protocol::Transaction_Contract_ContractType >(type_);
}
inline void Transaction_Contract::set_type(::protocol::Transaction_Contract_ContractType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.type)
}

// .google.protobuf.Any parameter = 2;
inline bool Transaction_Contract::has_parameter() const {
  return this != internal_default_instance() && parameter_ != NULL;
}
inline void Transaction_Contract::clear_parameter() {
  if (GetArenaNoVirtual() == NULL && parameter_ != NULL) delete parameter_;
  parameter_ = NULL;
}
inline const ::google::protobuf::Any& Transaction_Contract::parameter() const {
  const ::google::protobuf::Any* p = parameter_;
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.parameter)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Transaction_Contract::mutable_parameter() {
  
  if (parameter_ == NULL) {
    parameter_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.parameter)
  return parameter_;
}
inline ::google::protobuf::Any* Transaction_Contract::release_parameter() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.parameter)
  
  ::google::protobuf::Any* temp = parameter_;
  parameter_ = NULL;
  return temp;
}
inline void Transaction_Contract::set_allocated_parameter(::google::protobuf::Any* parameter) {
  delete parameter_;
  parameter_ = parameter;
  if (parameter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.parameter)
}

// bytes provider = 3;
inline void Transaction_Contract::clear_provider() {
  provider_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_Contract::provider() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.provider)
  return provider_.GetNoArena();
}
inline void Transaction_Contract::set_provider(const ::std::string& value) {
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.provider)
}
#if LANG_CXX11
inline void Transaction_Contract::set_provider(::std::string&& value) {
  
  provider_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.Contract.provider)
}
#endif
inline void Transaction_Contract::set_provider(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.Contract.provider)
}
inline void Transaction_Contract::set_provider(const void* value, size_t size) {
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.Contract.provider)
}
inline ::std::string* Transaction_Contract::mutable_provider() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.provider)
  return provider_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_Contract::release_provider() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.provider)
  
  return provider_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_Contract::set_allocated_provider(::std::string* provider) {
  if (provider != NULL) {
    
  } else {
    
  }
  provider_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), provider);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.provider)
}

// bytes ContractName = 4;
inline void Transaction_Contract::clear_contractname() {
  contractname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_Contract::contractname() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.ContractName)
  return contractname_.GetNoArena();
}
inline void Transaction_Contract::set_contractname(const ::std::string& value) {
  
  contractname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.ContractName)
}
#if LANG_CXX11
inline void Transaction_Contract::set_contractname(::std::string&& value) {
  
  contractname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.Contract.ContractName)
}
#endif
inline void Transaction_Contract::set_contractname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contractname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.Contract.ContractName)
}
inline void Transaction_Contract::set_contractname(const void* value, size_t size) {
  
  contractname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.Contract.ContractName)
}
inline ::std::string* Transaction_Contract::mutable_contractname() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.ContractName)
  return contractname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_Contract::release_contractname() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.ContractName)
  
  return contractname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_Contract::set_allocated_contractname(::std::string* contractname) {
  if (contractname != NULL) {
    
  } else {
    
  }
  contractname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contractname);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.ContractName)
}

// -------------------------------------------------------------------

// Transaction_Result

// int64 fee = 1;
inline void Transaction_Result::clear_fee() {
  fee_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_Result::fee() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.fee)
  return fee_;
}
inline void Transaction_Result::set_fee(::google::protobuf::int64 value) {
  
  fee_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.fee)
}

// .protocol.Transaction.Result.code ret = 2;
inline void Transaction_Result::clear_ret() {
  ret_ = 0;
}
inline ::protocol::Transaction_Result_code Transaction_Result::ret() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.ret)
  return static_cast< ::protocol::Transaction_Result_code >(ret_);
}
inline void Transaction_Result::set_ret(::protocol::Transaction_Result_code value) {
  
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.ret)
}

// -------------------------------------------------------------------

// Transaction_raw

// bytes ref_block_bytes = 1;
inline void Transaction_raw::clear_ref_block_bytes() {
  ref_block_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::ref_block_bytes() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_bytes)
  return ref_block_bytes_.GetNoArena();
}
inline void Transaction_raw::set_ref_block_bytes(const ::std::string& value) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_bytes)
}
#if LANG_CXX11
inline void Transaction_raw::set_ref_block_bytes(::std::string&& value) {
  
  ref_block_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.ref_block_bytes)
}
#endif
inline void Transaction_raw::set_ref_block_bytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.ref_block_bytes)
}
inline void Transaction_raw::set_ref_block_bytes(const void* value, size_t size) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.ref_block_bytes)
}
inline ::std::string* Transaction_raw::mutable_ref_block_bytes() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_bytes)
  return ref_block_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_ref_block_bytes() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_bytes)
  
  return ref_block_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_ref_block_bytes(::std::string* ref_block_bytes) {
  if (ref_block_bytes != NULL) {
    
  } else {
    
  }
  ref_block_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_bytes);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_bytes)
}

// int64 ref_block_num = 3;
inline void Transaction_raw::clear_ref_block_num() {
  ref_block_num_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::ref_block_num() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_num)
  return ref_block_num_;
}
inline void Transaction_raw::set_ref_block_num(::google::protobuf::int64 value) {
  
  ref_block_num_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_num)
}

// bytes ref_block_hash = 4;
inline void Transaction_raw::clear_ref_block_hash() {
  ref_block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::ref_block_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_hash)
  return ref_block_hash_.GetNoArena();
}
inline void Transaction_raw::set_ref_block_hash(const ::std::string& value) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_hash)
}
#if LANG_CXX11
inline void Transaction_raw::set_ref_block_hash(::std::string&& value) {
  
  ref_block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.ref_block_hash)
}
#endif
inline void Transaction_raw::set_ref_block_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.ref_block_hash)
}
inline void Transaction_raw::set_ref_block_hash(const void* value, size_t size) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.ref_block_hash)
}
inline ::std::string* Transaction_raw::mutable_ref_block_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_hash)
  return ref_block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_ref_block_hash() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_hash)
  
  return ref_block_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_ref_block_hash(::std::string* ref_block_hash) {
  if (ref_block_hash != NULL) {
    
  } else {
    
  }
  ref_block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_hash)
}

// int64 expiration = 8;
inline void Transaction_raw::clear_expiration() {
  expiration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::expiration() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.expiration)
  return expiration_;
}
inline void Transaction_raw::set_expiration(::google::protobuf::int64 value) {
  
  expiration_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.expiration)
}

// repeated .protocol.acuthrity auths = 9;
inline int Transaction_raw::auths_size() const {
  return auths_.size();
}
inline void Transaction_raw::clear_auths() {
  auths_.Clear();
}
inline const ::protocol::acuthrity& Transaction_raw::auths(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.auths)
  return auths_.Get(index);
}
inline ::protocol::acuthrity* Transaction_raw::mutable_auths(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.auths)
  return auths_.Mutable(index);
}
inline ::protocol::acuthrity* Transaction_raw::add_auths() {
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.auths)
  return auths_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::acuthrity >*
Transaction_raw::mutable_auths() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.auths)
  return &auths_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::acuthrity >&
Transaction_raw::auths() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.auths)
  return auths_;
}

// bytes data = 10;
inline void Transaction_raw::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::data() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.data)
  return data_.GetNoArena();
}
inline void Transaction_raw::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.data)
}
#if LANG_CXX11
inline void Transaction_raw::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.data)
}
#endif
inline void Transaction_raw::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.data)
}
inline void Transaction_raw::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.data)
}
inline ::std::string* Transaction_raw::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.data)
}

// repeated .protocol.Transaction.Contract contract = 11;
inline int Transaction_raw::contract_size() const {
  return contract_.size();
}
inline void Transaction_raw::clear_contract() {
  contract_.Clear();
}
inline const ::protocol::Transaction_Contract& Transaction_raw::contract(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.contract)
  return contract_.Get(index);
}
inline ::protocol::Transaction_Contract* Transaction_raw::mutable_contract(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.contract)
  return contract_.Mutable(index);
}
inline ::protocol::Transaction_Contract* Transaction_raw::add_contract() {
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.contract)
  return contract_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >*
Transaction_raw::mutable_contract() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.contract)
  return &contract_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >&
Transaction_raw::contract() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.contract)
  return contract_;
}

// bytes scripts = 12;
inline void Transaction_raw::clear_scripts() {
  scripts_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::scripts() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.scripts)
  return scripts_.GetNoArena();
}
inline void Transaction_raw::set_scripts(const ::std::string& value) {
  
  scripts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.scripts)
}
#if LANG_CXX11
inline void Transaction_raw::set_scripts(::std::string&& value) {
  
  scripts_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.scripts)
}
#endif
inline void Transaction_raw::set_scripts(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  scripts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.scripts)
}
inline void Transaction_raw::set_scripts(const void* value, size_t size) {
  
  scripts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.scripts)
}
inline ::std::string* Transaction_raw::mutable_scripts() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.scripts)
  return scripts_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_scripts() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.scripts)
  
  return scripts_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_scripts(::std::string* scripts) {
  if (scripts != NULL) {
    
  } else {
    
  }
  scripts_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scripts);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.scripts)
}

// int64 timestamp = 14;
inline void Transaction_raw::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.timestamp)
  return timestamp_;
}
inline void Transaction_raw::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.timestamp)
}

// -------------------------------------------------------------------

// Transaction

// .protocol.Transaction.raw raw_data = 1;
inline bool Transaction::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != NULL;
}
inline void Transaction::clear_raw_data() {
  if (GetArenaNoVirtual() == NULL && raw_data_ != NULL) delete raw_data_;
  raw_data_ = NULL;
}
inline const ::protocol::Transaction_raw& Transaction::raw_data() const {
  const ::protocol::Transaction_raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw_data)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::Transaction_raw*>(
      &::protocol::_Transaction_raw_default_instance_);
}
inline ::protocol::Transaction_raw* Transaction::mutable_raw_data() {
  
  if (raw_data_ == NULL) {
    raw_data_ = new ::protocol::Transaction_raw;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw_data)
  return raw_data_;
}
inline ::protocol::Transaction_raw* Transaction::release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw_data)
  
  ::protocol::Transaction_raw* temp = raw_data_;
  raw_data_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_raw_data(::protocol::Transaction_raw* raw_data) {
  delete raw_data_;
  raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw_data)
}

// repeated bytes signature = 2;
inline int Transaction::signature_size() const {
  return signature_.size();
}
inline void Transaction::clear_signature() {
  signature_.Clear();
}
inline const ::std::string& Transaction::signature(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.signature)
  return signature_.Get(index);
}
inline ::std::string* Transaction::mutable_signature(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.signature)
  return signature_.Mutable(index);
}
inline void Transaction::set_signature(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.Transaction.signature)
  signature_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Transaction::set_signature(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.Transaction.signature)
  signature_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Transaction::set_signature(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.signature)
}
inline void Transaction::set_signature(int index, const void* value, size_t size) {
  signature_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.signature)
}
inline ::std::string* Transaction::add_signature() {
  // @@protoc_insertion_point(field_add_mutable:protocol.Transaction.signature)
  return signature_.Add();
}
inline void Transaction::add_signature(const ::std::string& value) {
  signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.Transaction.signature)
}
#if LANG_CXX11
inline void Transaction::add_signature(::std::string&& value) {
  signature_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.Transaction.signature)
}
#endif
inline void Transaction::add_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.Transaction.signature)
}
inline void Transaction::add_signature(const void* value, size_t size) {
  signature_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.Transaction.signature)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Transaction::signature() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.signature)
  return signature_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Transaction::mutable_signature() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.signature)
  return &signature_;
}

// repeated .protocol.Transaction.Result ret = 5;
inline int Transaction::ret_size() const {
  return ret_.size();
}
inline void Transaction::clear_ret() {
  ret_.Clear();
}
inline const ::protocol::Transaction_Result& Transaction::ret(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.ret)
  return ret_.Get(index);
}
inline ::protocol::Transaction_Result* Transaction::mutable_ret(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.ret)
  return ret_.Mutable(index);
}
inline ::protocol::Transaction_Result* Transaction::add_ret() {
  // @@protoc_insertion_point(field_add:protocol.Transaction.ret)
  return ret_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Result >*
Transaction::mutable_ret() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.ret)
  return &ret_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Result >&
Transaction::ret() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.ret)
  return ret_;
}

// -------------------------------------------------------------------

// Transactions

// repeated .protocol.Transaction transactions = 1;
inline int Transactions::transactions_size() const {
  return transactions_.size();
}
inline void Transactions::clear_transactions() {
  transactions_.Clear();
}
inline const ::protocol::Transaction& Transactions::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transactions.transactions)
  return transactions_.Get(index);
}
inline ::protocol::Transaction* Transactions::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transactions.transactions)
  return transactions_.Mutable(index);
}
inline ::protocol::Transaction* Transactions::add_transactions() {
  // @@protoc_insertion_point(field_add:protocol.Transactions.transactions)
  return transactions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
Transactions::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transactions.transactions)
  return &transactions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
Transactions::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.Transactions.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// BlockHeader_raw

// int64 timestamp = 1;
inline void BlockHeader_raw::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.timestamp)
  return timestamp_;
}
inline void BlockHeader_raw::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.timestamp)
}

// bytes txTrieRoot = 2;
inline void BlockHeader_raw::clear_txtrieroot() {
  txtrieroot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::txtrieroot() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.txTrieRoot)
  return txtrieroot_.GetNoArena();
}
inline void BlockHeader_raw::set_txtrieroot(const ::std::string& value) {
  
  txtrieroot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.txTrieRoot)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_txtrieroot(::std::string&& value) {
  
  txtrieroot_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.txTrieRoot)
}
#endif
inline void BlockHeader_raw::set_txtrieroot(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txtrieroot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.txTrieRoot)
}
inline void BlockHeader_raw::set_txtrieroot(const void* value, size_t size) {
  
  txtrieroot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.txTrieRoot)
}
inline ::std::string* BlockHeader_raw::mutable_txtrieroot() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.txTrieRoot)
  return txtrieroot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_txtrieroot() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.txTrieRoot)
  
  return txtrieroot_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_txtrieroot(::std::string* txtrieroot) {
  if (txtrieroot != NULL) {
    
  } else {
    
  }
  txtrieroot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txtrieroot);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.txTrieRoot)
}

// bytes parentHash = 3;
inline void BlockHeader_raw::clear_parenthash() {
  parenthash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::parenthash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.parentHash)
  return parenthash_.GetNoArena();
}
inline void BlockHeader_raw::set_parenthash(const ::std::string& value) {
  
  parenthash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.parentHash)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_parenthash(::std::string&& value) {
  
  parenthash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.parentHash)
}
#endif
inline void BlockHeader_raw::set_parenthash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parenthash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.parentHash)
}
inline void BlockHeader_raw::set_parenthash(const void* value, size_t size) {
  
  parenthash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.parentHash)
}
inline ::std::string* BlockHeader_raw::mutable_parenthash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.parentHash)
  return parenthash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_parenthash() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.parentHash)
  
  return parenthash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_parenthash(::std::string* parenthash) {
  if (parenthash != NULL) {
    
  } else {
    
  }
  parenthash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parenthash);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.parentHash)
}

// int64 number = 7;
inline void BlockHeader_raw::clear_number() {
  number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.number)
  return number_;
}
inline void BlockHeader_raw::set_number(::google::protobuf::int64 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.number)
}

// int64 witness_id = 8;
inline void BlockHeader_raw::clear_witness_id() {
  witness_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::witness_id() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_id)
  return witness_id_;
}
inline void BlockHeader_raw::set_witness_id(::google::protobuf::int64 value) {
  
  witness_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_id)
}

// bytes witness_address = 9;
inline void BlockHeader_raw::clear_witness_address() {
  witness_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::witness_address() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_address)
  return witness_address_.GetNoArena();
}
inline void BlockHeader_raw::set_witness_address(const ::std::string& value) {
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_address)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_witness_address(::std::string&& value) {
  
  witness_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.witness_address)
}
#endif
inline void BlockHeader_raw::set_witness_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.witness_address)
}
inline void BlockHeader_raw::set_witness_address(const void* value, size_t size) {
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.witness_address)
}
inline ::std::string* BlockHeader_raw::mutable_witness_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.witness_address)
  return witness_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_witness_address() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.witness_address)
  
  return witness_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_witness_address(::std::string* witness_address) {
  if (witness_address != NULL) {
    
  } else {
    
  }
  witness_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), witness_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.witness_address)
}

// -------------------------------------------------------------------

// BlockHeader

// .protocol.BlockHeader.raw raw_data = 1;
inline bool BlockHeader::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != NULL;
}
inline void BlockHeader::clear_raw_data() {
  if (GetArenaNoVirtual() == NULL && raw_data_ != NULL) delete raw_data_;
  raw_data_ = NULL;
}
inline const ::protocol::BlockHeader_raw& BlockHeader::raw_data() const {
  const ::protocol::BlockHeader_raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw_data)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::BlockHeader_raw*>(
      &::protocol::_BlockHeader_raw_default_instance_);
}
inline ::protocol::BlockHeader_raw* BlockHeader::mutable_raw_data() {
  
  if (raw_data_ == NULL) {
    raw_data_ = new ::protocol::BlockHeader_raw;
  }
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw_data)
  return raw_data_;
}
inline ::protocol::BlockHeader_raw* BlockHeader::release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw_data)
  
  ::protocol::BlockHeader_raw* temp = raw_data_;
  raw_data_ = NULL;
  return temp;
}
inline void BlockHeader::set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data) {
  delete raw_data_;
  raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw_data)
}

// bytes witness_signature = 2;
inline void BlockHeader::clear_witness_signature() {
  witness_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader::witness_signature() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.witness_signature)
  return witness_signature_.GetNoArena();
}
inline void BlockHeader::set_witness_signature(const ::std::string& value) {
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.witness_signature)
}
#if LANG_CXX11
inline void BlockHeader::set_witness_signature(::std::string&& value) {
  
  witness_signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.witness_signature)
}
#endif
inline void BlockHeader::set_witness_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.witness_signature)
}
inline void BlockHeader::set_witness_signature(const void* value, size_t size) {
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.witness_signature)
}
inline ::std::string* BlockHeader::mutable_witness_signature() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.witness_signature)
  return witness_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader::release_witness_signature() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.witness_signature)
  
  return witness_signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader::set_allocated_witness_signature(::std::string* witness_signature) {
  if (witness_signature != NULL) {
    
  } else {
    
  }
  witness_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), witness_signature);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.witness_signature)
}

// -------------------------------------------------------------------

// Block

// repeated .protocol.Transaction transactions = 1;
inline int Block::transactions_size() const {
  return transactions_.size();
}
inline void Block::clear_transactions() {
  transactions_.Clear();
}
inline const ::protocol::Transaction& Block::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Block.transactions)
  return transactions_.Get(index);
}
inline ::protocol::Transaction* Block::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Block.transactions)
  return transactions_.Mutable(index);
}
inline ::protocol::Transaction* Block::add_transactions() {
  // @@protoc_insertion_point(field_add:protocol.Block.transactions)
  return transactions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
Block::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Block.transactions)
  return &transactions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
Block::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.Block.transactions)
  return transactions_;
}

// .protocol.BlockHeader block_header = 2;
inline bool Block::has_block_header() const {
  return this != internal_default_instance() && block_header_ != NULL;
}
inline void Block::clear_block_header() {
  if (GetArenaNoVirtual() == NULL && block_header_ != NULL) delete block_header_;
  block_header_ = NULL;
}
inline const ::protocol::BlockHeader& Block::block_header() const {
  const ::protocol::BlockHeader* p = block_header_;
  // @@protoc_insertion_point(field_get:protocol.Block.block_header)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::BlockHeader*>(
      &::protocol::_BlockHeader_default_instance_);
}
inline ::protocol::BlockHeader* Block::mutable_block_header() {
  
  if (block_header_ == NULL) {
    block_header_ = new ::protocol::BlockHeader;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Block.block_header)
  return block_header_;
}
inline ::protocol::BlockHeader* Block::release_block_header() {
  // @@protoc_insertion_point(field_release:protocol.Block.block_header)
  
  ::protocol::BlockHeader* temp = block_header_;
  block_header_ = NULL;
  return temp;
}
inline void Block::set_allocated_block_header(::protocol::BlockHeader* block_header) {
  delete block_header_;
  block_header_ = block_header;
  if (block_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Block.block_header)
}

// -------------------------------------------------------------------

// ChainInventory_BlockId

// bytes hash = 1;
inline void ChainInventory_BlockId::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChainInventory_BlockId::hash() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.BlockId.hash)
  return hash_.GetNoArena();
}
inline void ChainInventory_BlockId::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainInventory.BlockId.hash)
}
#if LANG_CXX11
inline void ChainInventory_BlockId::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainInventory.BlockId.hash)
}
#endif
inline void ChainInventory_BlockId::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainInventory.BlockId.hash)
}
inline void ChainInventory_BlockId::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainInventory.BlockId.hash)
}
inline ::std::string* ChainInventory_BlockId::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.ChainInventory.BlockId.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainInventory_BlockId::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.ChainInventory.BlockId.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainInventory_BlockId::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainInventory.BlockId.hash)
}

// int64 number = 2;
inline void ChainInventory_BlockId::clear_number() {
  number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainInventory_BlockId::number() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.BlockId.number)
  return number_;
}
inline void ChainInventory_BlockId::set_number(::google::protobuf::int64 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainInventory.BlockId.number)
}

// -------------------------------------------------------------------

// ChainInventory

// repeated .protocol.ChainInventory.BlockId ids = 1;
inline int ChainInventory::ids_size() const {
  return ids_.size();
}
inline void ChainInventory::clear_ids() {
  ids_.Clear();
}
inline const ::protocol::ChainInventory_BlockId& ChainInventory::ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.ids)
  return ids_.Get(index);
}
inline ::protocol::ChainInventory_BlockId* ChainInventory::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ChainInventory.ids)
  return ids_.Mutable(index);
}
inline ::protocol::ChainInventory_BlockId* ChainInventory::add_ids() {
  // @@protoc_insertion_point(field_add:protocol.ChainInventory.ids)
  return ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::ChainInventory_BlockId >*
ChainInventory::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainInventory.ids)
  return &ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::ChainInventory_BlockId >&
ChainInventory::ids() const {
  // @@protoc_insertion_point(field_list:protocol.ChainInventory.ids)
  return ids_;
}

// int64 remain_num = 2;
inline void ChainInventory::clear_remain_num() {
  remain_num_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ChainInventory::remain_num() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.remain_num)
  return remain_num_;
}
inline void ChainInventory::set_remain_num(::google::protobuf::int64 value) {
  
  remain_num_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainInventory.remain_num)
}

// -------------------------------------------------------------------

// BlockInventory_BlockId

// bytes hash = 1;
inline void BlockInventory_BlockId::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockInventory_BlockId::hash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.BlockId.hash)
  return hash_.GetNoArena();
}
inline void BlockInventory_BlockId::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockInventory.BlockId.hash)
}
#if LANG_CXX11
inline void BlockInventory_BlockId::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockInventory.BlockId.hash)
}
#endif
inline void BlockInventory_BlockId::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockInventory.BlockId.hash)
}
inline void BlockInventory_BlockId::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockInventory.BlockId.hash)
}
inline ::std::string* BlockInventory_BlockId::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockInventory.BlockId.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockInventory_BlockId::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.BlockInventory.BlockId.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockInventory_BlockId::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockInventory.BlockId.hash)
}

// int64 number = 2;
inline void BlockInventory_BlockId::clear_number() {
  number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockInventory_BlockId::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.BlockId.number)
  return number_;
}
inline void BlockInventory_BlockId::set_number(::google::protobuf::int64 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockInventory.BlockId.number)
}

// -------------------------------------------------------------------

// BlockInventory

// repeated .protocol.BlockInventory.BlockId ids = 1;
inline int BlockInventory::ids_size() const {
  return ids_.size();
}
inline void BlockInventory::clear_ids() {
  ids_.Clear();
}
inline const ::protocol::BlockInventory_BlockId& BlockInventory::ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.ids)
  return ids_.Get(index);
}
inline ::protocol::BlockInventory_BlockId* BlockInventory::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BlockInventory.ids)
  return ids_.Mutable(index);
}
inline ::protocol::BlockInventory_BlockId* BlockInventory::add_ids() {
  // @@protoc_insertion_point(field_add:protocol.BlockInventory.ids)
  return ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::BlockInventory_BlockId >*
BlockInventory::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BlockInventory.ids)
  return &ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::BlockInventory_BlockId >&
BlockInventory::ids() const {
  // @@protoc_insertion_point(field_list:protocol.BlockInventory.ids)
  return ids_;
}

// .protocol.BlockInventory.Type type = 2;
inline void BlockInventory::clear_type() {
  type_ = 0;
}
inline ::protocol::BlockInventory_Type BlockInventory::type() const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.type)
  return static_cast< ::protocol::BlockInventory_Type >(type_);
}
inline void BlockInventory::set_type(::protocol::BlockInventory_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockInventory.type)
}

// -------------------------------------------------------------------

// Inventory

// .protocol.Inventory.InventoryType type = 1;
inline void Inventory::clear_type() {
  type_ = 0;
}
inline ::protocol::Inventory_InventoryType Inventory::type() const {
  // @@protoc_insertion_point(field_get:protocol.Inventory.type)
  return static_cast< ::protocol::Inventory_InventoryType >(type_);
}
inline void Inventory::set_type(::protocol::Inventory_InventoryType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Inventory.type)
}

// repeated bytes ids = 2;
inline int Inventory::ids_size() const {
  return ids_.size();
}
inline void Inventory::clear_ids() {
  ids_.Clear();
}
inline const ::std::string& Inventory::ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Inventory.ids)
  return ids_.Get(index);
}
inline ::std::string* Inventory::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Inventory.ids)
  return ids_.Mutable(index);
}
inline void Inventory::set_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.Inventory.ids)
  ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Inventory::set_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.Inventory.ids)
  ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Inventory::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Inventory.ids)
}
inline void Inventory::set_ids(int index, const void* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Inventory.ids)
}
inline ::std::string* Inventory::add_ids() {
  // @@protoc_insertion_point(field_add_mutable:protocol.Inventory.ids)
  return ids_.Add();
}
inline void Inventory::add_ids(const ::std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.Inventory.ids)
}
#if LANG_CXX11
inline void Inventory::add_ids(::std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.Inventory.ids)
}
#endif
inline void Inventory::add_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.Inventory.ids)
}
inline void Inventory::add_ids(const void* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.Inventory.ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Inventory::ids() const {
  // @@protoc_insertion_point(field_list:protocol.Inventory.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Inventory::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Inventory.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// Items

// .protocol.Items.ItemType type = 1;
inline void Items::clear_type() {
  type_ = 0;
}
inline ::protocol::Items_ItemType Items::type() const {
  // @@protoc_insertion_point(field_get:protocol.Items.type)
  return static_cast< ::protocol::Items_ItemType >(type_);
}
inline void Items::set_type(::protocol::Items_ItemType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Items.type)
}

// repeated .protocol.Block blocks = 2;
inline int Items::blocks_size() const {
  return blocks_.size();
}
inline void Items::clear_blocks() {
  blocks_.Clear();
}
inline const ::protocol::Block& Items::blocks(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Items.blocks)
  return blocks_.Get(index);
}
inline ::protocol::Block* Items::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Items.blocks)
  return blocks_.Mutable(index);
}
inline ::protocol::Block* Items::add_blocks() {
  // @@protoc_insertion_point(field_add:protocol.Items.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Block >*
Items::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Items.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Block >&
Items::blocks() const {
  // @@protoc_insertion_point(field_list:protocol.Items.blocks)
  return blocks_;
}

// repeated .protocol.BlockHeader block_headers = 3;
inline int Items::block_headers_size() const {
  return block_headers_.size();
}
inline void Items::clear_block_headers() {
  block_headers_.Clear();
}
inline const ::protocol::BlockHeader& Items::block_headers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Items.block_headers)
  return block_headers_.Get(index);
}
inline ::protocol::BlockHeader* Items::mutable_block_headers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Items.block_headers)
  return block_headers_.Mutable(index);
}
inline ::protocol::BlockHeader* Items::add_block_headers() {
  // @@protoc_insertion_point(field_add:protocol.Items.block_headers)
  return block_headers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::BlockHeader >*
Items::mutable_block_headers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Items.block_headers)
  return &block_headers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::BlockHeader >&
Items::block_headers() const {
  // @@protoc_insertion_point(field_list:protocol.Items.block_headers)
  return block_headers_;
}

// repeated .protocol.Transaction transactions = 4;
inline int Items::transactions_size() const {
  return transactions_.size();
}
inline void Items::clear_transactions() {
  transactions_.Clear();
}
inline const ::protocol::Transaction& Items::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Items.transactions)
  return transactions_.Get(index);
}
inline ::protocol::Transaction* Items::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Items.transactions)
  return transactions_.Mutable(index);
}
inline ::protocol::Transaction* Items::add_transactions() {
  // @@protoc_insertion_point(field_add:protocol.Items.transactions)
  return transactions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
Items::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Items.transactions)
  return &transactions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
Items::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.Items.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// DynamicProperties

// int64 last_solidity_block_num = 1;
inline void DynamicProperties::clear_last_solidity_block_num() {
  last_solidity_block_num_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DynamicProperties::last_solidity_block_num() const {
  // @@protoc_insertion_point(field_get:protocol.DynamicProperties.last_solidity_block_num)
  return last_solidity_block_num_;
}
inline void DynamicProperties::set_last_solidity_block_num(::google::protobuf::int64 value) {
  
  last_solidity_block_num_ = value;
  // @@protoc_insertion_point(field_set:protocol.DynamicProperties.last_solidity_block_num)
}

// -------------------------------------------------------------------

// DisconnectMessage

// .protocol.ReasonCode reason = 1;
inline void DisconnectMessage::clear_reason() {
  reason_ = 0;
}
inline ::protocol::ReasonCode DisconnectMessage::reason() const {
  // @@protoc_insertion_point(field_get:protocol.DisconnectMessage.reason)
  return static_cast< ::protocol::ReasonCode >(reason_);
}
inline void DisconnectMessage::set_reason(::protocol::ReasonCode value) {
  
  reason_ = value;
  // @@protoc_insertion_point(field_set:protocol.DisconnectMessage.reason)
}

// -------------------------------------------------------------------

// HelloMessage_BlockId

// bytes hash = 1;
inline void HelloMessage_BlockId::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloMessage_BlockId::hash() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.BlockId.hash)
  return hash_.GetNoArena();
}
inline void HelloMessage_BlockId::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.BlockId.hash)
}
#if LANG_CXX11
inline void HelloMessage_BlockId::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.HelloMessage.BlockId.hash)
}
#endif
inline void HelloMessage_BlockId::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.HelloMessage.BlockId.hash)
}
inline void HelloMessage_BlockId::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.HelloMessage.BlockId.hash)
}
inline ::std::string* HelloMessage_BlockId::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.BlockId.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloMessage_BlockId::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.BlockId.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloMessage_BlockId::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.BlockId.hash)
}

// int64 number = 2;
inline void HelloMessage_BlockId::clear_number() {
  number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HelloMessage_BlockId::number() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.BlockId.number)
  return number_;
}
inline void HelloMessage_BlockId::set_number(::google::protobuf::int64 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.BlockId.number)
}

// -------------------------------------------------------------------

// HelloMessage

// .protocol.Endpoint from = 1;
inline bool HelloMessage::has_from() const {
  return this != internal_default_instance() && from_ != NULL;
}
inline void HelloMessage::clear_from() {
  if (GetArenaNoVirtual() == NULL && from_ != NULL) delete from_;
  from_ = NULL;
}
inline const ::protocol::Endpoint& HelloMessage::from() const {
  const ::protocol::Endpoint* p = from_;
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.from)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::Endpoint*>(
      &::protocol::_Endpoint_default_instance_);
}
inline ::protocol::Endpoint* HelloMessage::mutable_from() {
  
  if (from_ == NULL) {
    from_ = new ::protocol::Endpoint;
  }
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.from)
  return from_;
}
inline ::protocol::Endpoint* HelloMessage::release_from() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.from)
  
  ::protocol::Endpoint* temp = from_;
  from_ = NULL;
  return temp;
}
inline void HelloMessage::set_allocated_from(::protocol::Endpoint* from) {
  delete from_;
  from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.from)
}

// int32 version = 2;
inline void HelloMessage::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 HelloMessage::version() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.version)
  return version_;
}
inline void HelloMessage::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.version)
}

// int64 timestamp = 3;
inline void HelloMessage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HelloMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.timestamp)
  return timestamp_;
}
inline void HelloMessage::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.timestamp)
}

// .protocol.HelloMessage.BlockId genesisBlockId = 4;
inline bool HelloMessage::has_genesisblockid() const {
  return this != internal_default_instance() && genesisblockid_ != NULL;
}
inline void HelloMessage::clear_genesisblockid() {
  if (GetArenaNoVirtual() == NULL && genesisblockid_ != NULL) delete genesisblockid_;
  genesisblockid_ = NULL;
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::genesisblockid() const {
  const ::protocol::HelloMessage_BlockId* p = genesisblockid_;
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.genesisBlockId)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::HelloMessage_BlockId*>(
      &::protocol::_HelloMessage_BlockId_default_instance_);
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::mutable_genesisblockid() {
  
  if (genesisblockid_ == NULL) {
    genesisblockid_ = new ::protocol::HelloMessage_BlockId;
  }
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.genesisBlockId)
  return genesisblockid_;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::release_genesisblockid() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.genesisBlockId)
  
  ::protocol::HelloMessage_BlockId* temp = genesisblockid_;
  genesisblockid_ = NULL;
  return temp;
}
inline void HelloMessage::set_allocated_genesisblockid(::protocol::HelloMessage_BlockId* genesisblockid) {
  delete genesisblockid_;
  genesisblockid_ = genesisblockid;
  if (genesisblockid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.genesisBlockId)
}

// .protocol.HelloMessage.BlockId solidBlockId = 5;
inline bool HelloMessage::has_solidblockid() const {
  return this != internal_default_instance() && solidblockid_ != NULL;
}
inline void HelloMessage::clear_solidblockid() {
  if (GetArenaNoVirtual() == NULL && solidblockid_ != NULL) delete solidblockid_;
  solidblockid_ = NULL;
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::solidblockid() const {
  const ::protocol::HelloMessage_BlockId* p = solidblockid_;
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.solidBlockId)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::HelloMessage_BlockId*>(
      &::protocol::_HelloMessage_BlockId_default_instance_);
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::mutable_solidblockid() {
  
  if (solidblockid_ == NULL) {
    solidblockid_ = new ::protocol::HelloMessage_BlockId;
  }
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.solidBlockId)
  return solidblockid_;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::release_solidblockid() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.solidBlockId)
  
  ::protocol::HelloMessage_BlockId* temp = solidblockid_;
  solidblockid_ = NULL;
  return temp;
}
inline void HelloMessage::set_allocated_solidblockid(::protocol::HelloMessage_BlockId* solidblockid) {
  delete solidblockid_;
  solidblockid_ = solidblockid;
  if (solidblockid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.solidBlockId)
}

// .protocol.HelloMessage.BlockId headBlockId = 6;
inline bool HelloMessage::has_headblockid() const {
  return this != internal_default_instance() && headblockid_ != NULL;
}
inline void HelloMessage::clear_headblockid() {
  if (GetArenaNoVirtual() == NULL && headblockid_ != NULL) delete headblockid_;
  headblockid_ = NULL;
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::headblockid() const {
  const ::protocol::HelloMessage_BlockId* p = headblockid_;
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.headBlockId)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::HelloMessage_BlockId*>(
      &::protocol::_HelloMessage_BlockId_default_instance_);
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::mutable_headblockid() {
  
  if (headblockid_ == NULL) {
    headblockid_ = new ::protocol::HelloMessage_BlockId;
  }
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.headBlockId)
  return headblockid_;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::release_headblockid() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.headBlockId)
  
  ::protocol::HelloMessage_BlockId* temp = headblockid_;
  headblockid_ = NULL;
  return temp;
}
inline void HelloMessage::set_allocated_headblockid(::protocol::HelloMessage_BlockId* headblockid) {
  delete headblockid_;
  headblockid_ = headblockid;
  if (headblockid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.headBlockId)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Transaction_Contract_ContractType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Contract_ContractType>() {
  return ::protocol::Transaction_Contract_ContractType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Result_code>() {
  return ::protocol::Transaction_Result_code_descriptor();
}
template <> struct is_proto_enum< ::protocol::BlockInventory_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::BlockInventory_Type>() {
  return ::protocol::BlockInventory_Type_descriptor();
}
template <> struct is_proto_enum< ::protocol::Inventory_InventoryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Inventory_InventoryType>() {
  return ::protocol::Inventory_InventoryType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Items_ItemType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Items_ItemType>() {
  return ::protocol::Items_ItemType_descriptor();
}
template <> struct is_proto_enum< ::protocol::AccountType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::AccountType>() {
  return ::protocol::AccountType_descriptor();
}
template <> struct is_proto_enum< ::protocol::ReasonCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ReasonCode>() {
  return ::protocol::ReasonCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_core_2fTron_2eproto__INCLUDED
