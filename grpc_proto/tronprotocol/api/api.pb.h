// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/api.proto

#ifndef PROTOBUF_api_2fapi_2eproto__INCLUDED
#define PROTOBUF_api_2fapi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "core/Tron.pb.h"
#include "core/Contract.pb.h"
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
namespace protocol {
class AccountNetMessage;
class AccountNetMessageDefaultTypeInternal;
extern AccountNetMessageDefaultTypeInternal _AccountNetMessage_default_instance_;
class AccountNetMessage_AssetNetLimitEntry;
class AccountNetMessage_AssetNetLimitEntryDefaultTypeInternal;
extern AccountNetMessage_AssetNetLimitEntryDefaultTypeInternal _AccountNetMessage_AssetNetLimitEntry_default_instance_;
class AccountNetMessage_AssetNetUsedEntry;
class AccountNetMessage_AssetNetUsedEntryDefaultTypeInternal;
extern AccountNetMessage_AssetNetUsedEntryDefaultTypeInternal _AccountNetMessage_AssetNetUsedEntry_default_instance_;
class AccountPaginated;
class AccountPaginatedDefaultTypeInternal;
extern AccountPaginatedDefaultTypeInternal _AccountPaginated_default_instance_;
class Address;
class AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class AssetIssueList;
class AssetIssueListDefaultTypeInternal;
extern AssetIssueListDefaultTypeInternal _AssetIssueList_default_instance_;
class BlockLimit;
class BlockLimitDefaultTypeInternal;
extern BlockLimitDefaultTypeInternal _BlockLimit_default_instance_;
class BlockList;
class BlockListDefaultTypeInternal;
extern BlockListDefaultTypeInternal _BlockList_default_instance_;
class BlockReference;
class BlockReferenceDefaultTypeInternal;
extern BlockReferenceDefaultTypeInternal _BlockReference_default_instance_;
class BytesMessage;
class BytesMessageDefaultTypeInternal;
extern BytesMessageDefaultTypeInternal _BytesMessage_default_instance_;
class EmptyMessage;
class EmptyMessageDefaultTypeInternal;
extern EmptyMessageDefaultTypeInternal _EmptyMessage_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodeList;
class NodeListDefaultTypeInternal;
extern NodeListDefaultTypeInternal _NodeList_default_instance_;
class NumberMessage;
class NumberMessageDefaultTypeInternal;
extern NumberMessageDefaultTypeInternal _NumberMessage_default_instance_;
class Return;
class ReturnDefaultTypeInternal;
extern ReturnDefaultTypeInternal _Return_default_instance_;
class TimeMessage;
class TimeMessageDefaultTypeInternal;
extern TimeMessageDefaultTypeInternal _TimeMessage_default_instance_;
class TimePaginatedMessage;
class TimePaginatedMessageDefaultTypeInternal;
extern TimePaginatedMessageDefaultTypeInternal _TimePaginatedMessage_default_instance_;
class TransactionLimit;
class TransactionLimitDefaultTypeInternal;
extern TransactionLimitDefaultTypeInternal _TransactionLimit_default_instance_;
class TransactionList;
class TransactionListDefaultTypeInternal;
extern TransactionListDefaultTypeInternal _TransactionList_default_instance_;
class WitnessList;
class WitnessListDefaultTypeInternal;
extern WitnessListDefaultTypeInternal _WitnessList_default_instance_;
}  // namespace protocol

namespace protocol {

namespace protobuf_api_2fapi_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_api_2fapi_2eproto

enum Return_response_code {
  Return_response_code_SUCCESS = 0,
  Return_response_code_SIGERROR = 1,
  Return_response_code_CONTRACT_VALIDATE_ERROR = 2,
  Return_response_code_CONTRACT_EXE_ERROR = 3,
  Return_response_code_BANDWITH_ERROR = 4,
  Return_response_code_DUP_TRANSACTION_ERROR = 5,
  Return_response_code_TAPOS_ERROR = 6,
  Return_response_code_TOO_BIG_TRANSACTION_ERROR = 7,
  Return_response_code_TRANSACTION_EXPIRATION_ERROR = 8,
  Return_response_code_SERVER_BUSY = 9,
  Return_response_code_OTHER_ERROR = 20,
  Return_response_code_Return_response_code_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Return_response_code_Return_response_code_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Return_response_code_IsValid(int value);
const Return_response_code Return_response_code_response_code_MIN = Return_response_code_SUCCESS;
const Return_response_code Return_response_code_response_code_MAX = Return_response_code_OTHER_ERROR;
const int Return_response_code_response_code_ARRAYSIZE = Return_response_code_response_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* Return_response_code_descriptor();
inline const ::std::string& Return_response_code_Name(Return_response_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    Return_response_code_descriptor(), value);
}
inline bool Return_response_code_Parse(
    const ::std::string& name, Return_response_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Return_response_code>(
    Return_response_code_descriptor(), name, value);
}
// ===================================================================

class Return : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Return) */ {
 public:
  Return();
  virtual ~Return();

  Return(const Return& from);

  inline Return& operator=(const Return& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Return(Return&& from) noexcept
    : Return() {
    *this = ::std::move(from);
  }

  inline Return& operator=(Return&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Return& default_instance();

  static inline const Return* internal_default_instance() {
    return reinterpret_cast<const Return*>(
               &_Return_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Return* other);
  friend void swap(Return& a, Return& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Return* New() const PROTOBUF_FINAL { return New(NULL); }

  Return* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Return& from);
  void MergeFrom(const Return& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Return* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Return_response_code response_code;
  static const response_code SUCCESS =
    Return_response_code_SUCCESS;
  static const response_code SIGERROR =
    Return_response_code_SIGERROR;
  static const response_code CONTRACT_VALIDATE_ERROR =
    Return_response_code_CONTRACT_VALIDATE_ERROR;
  static const response_code CONTRACT_EXE_ERROR =
    Return_response_code_CONTRACT_EXE_ERROR;
  static const response_code BANDWITH_ERROR =
    Return_response_code_BANDWITH_ERROR;
  static const response_code DUP_TRANSACTION_ERROR =
    Return_response_code_DUP_TRANSACTION_ERROR;
  static const response_code TAPOS_ERROR =
    Return_response_code_TAPOS_ERROR;
  static const response_code TOO_BIG_TRANSACTION_ERROR =
    Return_response_code_TOO_BIG_TRANSACTION_ERROR;
  static const response_code TRANSACTION_EXPIRATION_ERROR =
    Return_response_code_TRANSACTION_EXPIRATION_ERROR;
  static const response_code SERVER_BUSY =
    Return_response_code_SERVER_BUSY;
  static const response_code OTHER_ERROR =
    Return_response_code_OTHER_ERROR;
  static inline bool response_code_IsValid(int value) {
    return Return_response_code_IsValid(value);
  }
  static const response_code response_code_MIN =
    Return_response_code_response_code_MIN;
  static const response_code response_code_MAX =
    Return_response_code_response_code_MAX;
  static const int response_code_ARRAYSIZE =
    Return_response_code_response_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  response_code_descriptor() {
    return Return_response_code_descriptor();
  }
  static inline const ::std::string& response_code_Name(response_code value) {
    return Return_response_code_Name(value);
  }
  static inline bool response_code_Parse(const ::std::string& name,
      response_code* value) {
    return Return_response_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes message = 3;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // .protocol.Return.response_code code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::protocol::Return_response_code code() const;
  void set_code(::protocol::Return_response_code value);

  // @@protoc_insertion_point(class_scope:protocol.Return)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool result_;
  int code_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockReference) */ {
 public:
  BlockReference();
  virtual ~BlockReference();

  BlockReference(const BlockReference& from);

  inline BlockReference& operator=(const BlockReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockReference(BlockReference&& from) noexcept
    : BlockReference() {
    *this = ::std::move(from);
  }

  inline BlockReference& operator=(BlockReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockReference& default_instance();

  static inline const BlockReference* internal_default_instance() {
    return reinterpret_cast<const BlockReference*>(
               &_BlockReference_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(BlockReference* other);
  friend void swap(BlockReference& a, BlockReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockReference* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockReference* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockReference& from);
  void MergeFrom(const BlockReference& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes block_hash = 2;
  void clear_block_hash();
  static const int kBlockHashFieldNumber = 2;
  const ::std::string& block_hash() const;
  void set_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_block_hash(::std::string&& value);
  #endif
  void set_block_hash(const char* value);
  void set_block_hash(const void* value, size_t size);
  ::std::string* mutable_block_hash();
  ::std::string* release_block_hash();
  void set_allocated_block_hash(::std::string* block_hash);

  // int64 block_num = 1;
  void clear_block_num();
  static const int kBlockNumFieldNumber = 1;
  ::google::protobuf::int64 block_num() const;
  void set_block_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.BlockReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr block_hash_;
  ::google::protobuf::int64 block_num_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WitnessList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.WitnessList) */ {
 public:
  WitnessList();
  virtual ~WitnessList();

  WitnessList(const WitnessList& from);

  inline WitnessList& operator=(const WitnessList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WitnessList(WitnessList&& from) noexcept
    : WitnessList() {
    *this = ::std::move(from);
  }

  inline WitnessList& operator=(WitnessList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WitnessList& default_instance();

  static inline const WitnessList* internal_default_instance() {
    return reinterpret_cast<const WitnessList*>(
               &_WitnessList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(WitnessList* other);
  friend void swap(WitnessList& a, WitnessList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WitnessList* New() const PROTOBUF_FINAL { return New(NULL); }

  WitnessList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WitnessList& from);
  void MergeFrom(const WitnessList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WitnessList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Witness witnesses = 1;
  int witnesses_size() const;
  void clear_witnesses();
  static const int kWitnessesFieldNumber = 1;
  const ::protocol::Witness& witnesses(int index) const;
  ::protocol::Witness* mutable_witnesses(int index);
  ::protocol::Witness* add_witnesses();
  ::google::protobuf::RepeatedPtrField< ::protocol::Witness >*
      mutable_witnesses();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Witness >&
      witnesses() const;

  // @@protoc_insertion_point(class_scope:protocol.WitnessList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Witness > witnesses_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssetIssueList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AssetIssueList) */ {
 public:
  AssetIssueList();
  virtual ~AssetIssueList();

  AssetIssueList(const AssetIssueList& from);

  inline AssetIssueList& operator=(const AssetIssueList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetIssueList(AssetIssueList&& from) noexcept
    : AssetIssueList() {
    *this = ::std::move(from);
  }

  inline AssetIssueList& operator=(AssetIssueList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetIssueList& default_instance();

  static inline const AssetIssueList* internal_default_instance() {
    return reinterpret_cast<const AssetIssueList*>(
               &_AssetIssueList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AssetIssueList* other);
  friend void swap(AssetIssueList& a, AssetIssueList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetIssueList* New() const PROTOBUF_FINAL { return New(NULL); }

  AssetIssueList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AssetIssueList& from);
  void MergeFrom(const AssetIssueList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AssetIssueList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.AssetIssueContract assetIssue = 1;
  int assetissue_size() const;
  void clear_assetissue();
  static const int kAssetIssueFieldNumber = 1;
  const ::protocol::AssetIssueContract& assetissue(int index) const;
  ::protocol::AssetIssueContract* mutable_assetissue(int index);
  ::protocol::AssetIssueContract* add_assetissue();
  ::google::protobuf::RepeatedPtrField< ::protocol::AssetIssueContract >*
      mutable_assetissue();
  const ::google::protobuf::RepeatedPtrField< ::protocol::AssetIssueContract >&
      assetissue() const;

  // @@protoc_insertion_point(class_scope:protocol.AssetIssueList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::AssetIssueContract > assetissue_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockList) */ {
 public:
  BlockList();
  virtual ~BlockList();

  BlockList(const BlockList& from);

  inline BlockList& operator=(const BlockList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockList(BlockList&& from) noexcept
    : BlockList() {
    *this = ::std::move(from);
  }

  inline BlockList& operator=(BlockList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockList& default_instance();

  static inline const BlockList* internal_default_instance() {
    return reinterpret_cast<const BlockList*>(
               &_BlockList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BlockList* other);
  friend void swap(BlockList& a, BlockList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockList* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockList& from);
  void MergeFrom(const BlockList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Block block = 1;
  int block_size() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  const ::protocol::Block& block(int index) const;
  ::protocol::Block* mutable_block(int index);
  ::protocol::Block* add_block();
  ::google::protobuf::RepeatedPtrField< ::protocol::Block >*
      mutable_block();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Block >&
      block() const;

  // @@protoc_insertion_point(class_scope:protocol.BlockList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Block > block_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionList) */ {
 public:
  TransactionList();
  virtual ~TransactionList();

  TransactionList(const TransactionList& from);

  inline TransactionList& operator=(const TransactionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionList(TransactionList&& from) noexcept
    : TransactionList() {
    *this = ::std::move(from);
  }

  inline TransactionList& operator=(TransactionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionList& default_instance();

  static inline const TransactionList* internal_default_instance() {
    return reinterpret_cast<const TransactionList*>(
               &_TransactionList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TransactionList* other);
  friend void swap(TransactionList& a, TransactionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionList* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionList& from);
  void MergeFrom(const TransactionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Transaction transaction = 1;
  int transaction_size() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  const ::protocol::Transaction& transaction(int index) const;
  ::protocol::Transaction* mutable_transaction(int index);
  ::protocol::Transaction* add_transaction();
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transaction();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
      transaction() const;

  // @@protoc_insertion_point(class_scope:protocol.TransactionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction > transaction_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.NodeList) */ {
 public:
  NodeList();
  virtual ~NodeList();

  NodeList(const NodeList& from);

  inline NodeList& operator=(const NodeList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeList(NodeList&& from) noexcept
    : NodeList() {
    *this = ::std::move(from);
  }

  inline NodeList& operator=(NodeList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeList& default_instance();

  static inline const NodeList* internal_default_instance() {
    return reinterpret_cast<const NodeList*>(
               &_NodeList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(NodeList* other);
  friend void swap(NodeList& a, NodeList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeList* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeList& from);
  void MergeFrom(const NodeList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Node nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  const ::protocol::Node& nodes(int index) const;
  ::protocol::Node* mutable_nodes(int index);
  ::protocol::Node* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::protocol::Node >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:protocol.NodeList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Node > nodes_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const PROTOBUF_FINAL { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .protocol.Address address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::protocol::Address& address() const;
  ::protocol::Address* mutable_address();
  ::protocol::Address* release_address();
  void set_allocated_address(::protocol::Address* address);

  // @@protoc_insertion_point(class_scope:protocol.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protocol::Address* address_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Address) */ {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(Address&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Address* other);
  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Address* New() const PROTOBUF_FINAL { return New(NULL); }

  Address* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes host = 1;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const void* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.Address)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmptyMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EmptyMessage) */ {
 public:
  EmptyMessage();
  virtual ~EmptyMessage();

  EmptyMessage(const EmptyMessage& from);

  inline EmptyMessage& operator=(const EmptyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EmptyMessage(EmptyMessage&& from) noexcept
    : EmptyMessage() {
    *this = ::std::move(from);
  }

  inline EmptyMessage& operator=(EmptyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyMessage& default_instance();

  static inline const EmptyMessage* internal_default_instance() {
    return reinterpret_cast<const EmptyMessage*>(
               &_EmptyMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(EmptyMessage* other);
  friend void swap(EmptyMessage& a, EmptyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmptyMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  EmptyMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmptyMessage& from);
  void MergeFrom(const EmptyMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmptyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protocol.EmptyMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NumberMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.NumberMessage) */ {
 public:
  NumberMessage();
  virtual ~NumberMessage();

  NumberMessage(const NumberMessage& from);

  inline NumberMessage& operator=(const NumberMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NumberMessage(NumberMessage&& from) noexcept
    : NumberMessage() {
    *this = ::std::move(from);
  }

  inline NumberMessage& operator=(NumberMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberMessage& default_instance();

  static inline const NumberMessage* internal_default_instance() {
    return reinterpret_cast<const NumberMessage*>(
               &_NumberMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(NumberMessage* other);
  friend void swap(NumberMessage& a, NumberMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NumberMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  NumberMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NumberMessage& from);
  void MergeFrom(const NumberMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NumberMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 num = 1;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int64 num() const;
  void set_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.NumberMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 num_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytesMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BytesMessage) */ {
 public:
  BytesMessage();
  virtual ~BytesMessage();

  BytesMessage(const BytesMessage& from);

  inline BytesMessage& operator=(const BytesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytesMessage(BytesMessage&& from) noexcept
    : BytesMessage() {
    *this = ::std::move(from);
  }

  inline BytesMessage& operator=(BytesMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BytesMessage& default_instance();

  static inline const BytesMessage* internal_default_instance() {
    return reinterpret_cast<const BytesMessage*>(
               &_BytesMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(BytesMessage* other);
  friend void swap(BytesMessage& a, BytesMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytesMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  BytesMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BytesMessage& from);
  void MergeFrom(const BytesMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BytesMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:protocol.BytesMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimeMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TimeMessage) */ {
 public:
  TimeMessage();
  virtual ~TimeMessage();

  TimeMessage(const TimeMessage& from);

  inline TimeMessage& operator=(const TimeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeMessage(TimeMessage&& from) noexcept
    : TimeMessage() {
    *this = ::std::move(from);
  }

  inline TimeMessage& operator=(TimeMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeMessage& default_instance();

  static inline const TimeMessage* internal_default_instance() {
    return reinterpret_cast<const TimeMessage*>(
               &_TimeMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TimeMessage* other);
  friend void swap(TimeMessage& a, TimeMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeMessage& from);
  void MergeFrom(const TimeMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 beginInMilliseconds = 1;
  void clear_begininmilliseconds();
  static const int kBeginInMillisecondsFieldNumber = 1;
  ::google::protobuf::int64 begininmilliseconds() const;
  void set_begininmilliseconds(::google::protobuf::int64 value);

  // int64 endInMilliseconds = 2;
  void clear_endinmilliseconds();
  static const int kEndInMillisecondsFieldNumber = 2;
  ::google::protobuf::int64 endinmilliseconds() const;
  void set_endinmilliseconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TimeMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 begininmilliseconds_;
  ::google::protobuf::int64 endinmilliseconds_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockLimit) */ {
 public:
  BlockLimit();
  virtual ~BlockLimit();

  BlockLimit(const BlockLimit& from);

  inline BlockLimit& operator=(const BlockLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockLimit(BlockLimit&& from) noexcept
    : BlockLimit() {
    *this = ::std::move(from);
  }

  inline BlockLimit& operator=(BlockLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockLimit& default_instance();

  static inline const BlockLimit* internal_default_instance() {
    return reinterpret_cast<const BlockLimit*>(
               &_BlockLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(BlockLimit* other);
  friend void swap(BlockLimit& a, BlockLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockLimit& from);
  void MergeFrom(const BlockLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 startNum = 1;
  void clear_startnum();
  static const int kStartNumFieldNumber = 1;
  ::google::protobuf::int64 startnum() const;
  void set_startnum(::google::protobuf::int64 value);

  // int64 endNum = 2;
  void clear_endnum();
  static const int kEndNumFieldNumber = 2;
  ::google::protobuf::int64 endnum() const;
  void set_endnum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.BlockLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 startnum_;
  ::google::protobuf::int64 endnum_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionLimit) */ {
 public:
  TransactionLimit();
  virtual ~TransactionLimit();

  TransactionLimit(const TransactionLimit& from);

  inline TransactionLimit& operator=(const TransactionLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionLimit(TransactionLimit&& from) noexcept
    : TransactionLimit() {
    *this = ::std::move(from);
  }

  inline TransactionLimit& operator=(TransactionLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionLimit& default_instance();

  static inline const TransactionLimit* internal_default_instance() {
    return reinterpret_cast<const TransactionLimit*>(
               &_TransactionLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TransactionLimit* other);
  friend void swap(TransactionLimit& a, TransactionLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionLimit& from);
  void MergeFrom(const TransactionLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes transactionId = 1;
  void clear_transactionid();
  static const int kTransactionIdFieldNumber = 1;
  const ::std::string& transactionid() const;
  void set_transactionid(const ::std::string& value);
  #if LANG_CXX11
  void set_transactionid(::std::string&& value);
  #endif
  void set_transactionid(const char* value);
  void set_transactionid(const void* value, size_t size);
  ::std::string* mutable_transactionid();
  ::std::string* release_transactionid();
  void set_allocated_transactionid(::std::string* transactionid);

  // int64 limitNum = 2;
  void clear_limitnum();
  static const int kLimitNumFieldNumber = 2;
  ::google::protobuf::int64 limitnum() const;
  void set_limitnum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TransactionLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr transactionid_;
  ::google::protobuf::int64 limitnum_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountPaginated : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AccountPaginated) */ {
 public:
  AccountPaginated();
  virtual ~AccountPaginated();

  AccountPaginated(const AccountPaginated& from);

  inline AccountPaginated& operator=(const AccountPaginated& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountPaginated(AccountPaginated&& from) noexcept
    : AccountPaginated() {
    *this = ::std::move(from);
  }

  inline AccountPaginated& operator=(AccountPaginated&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountPaginated& default_instance();

  static inline const AccountPaginated* internal_default_instance() {
    return reinterpret_cast<const AccountPaginated*>(
               &_AccountPaginated_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(AccountPaginated* other);
  friend void swap(AccountPaginated& a, AccountPaginated& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountPaginated* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountPaginated* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountPaginated& from);
  void MergeFrom(const AccountPaginated& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountPaginated* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .protocol.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::protocol::Account& account() const;
  ::protocol::Account* mutable_account();
  ::protocol::Account* release_account();
  void set_allocated_account(::protocol::Account* account);

  // int64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // int64 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.AccountPaginated)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protocol::Account* account_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 limit_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimePaginatedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TimePaginatedMessage) */ {
 public:
  TimePaginatedMessage();
  virtual ~TimePaginatedMessage();

  TimePaginatedMessage(const TimePaginatedMessage& from);

  inline TimePaginatedMessage& operator=(const TimePaginatedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimePaginatedMessage(TimePaginatedMessage&& from) noexcept
    : TimePaginatedMessage() {
    *this = ::std::move(from);
  }

  inline TimePaginatedMessage& operator=(TimePaginatedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimePaginatedMessage& default_instance();

  static inline const TimePaginatedMessage* internal_default_instance() {
    return reinterpret_cast<const TimePaginatedMessage*>(
               &_TimePaginatedMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(TimePaginatedMessage* other);
  friend void swap(TimePaginatedMessage& a, TimePaginatedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimePaginatedMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  TimePaginatedMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimePaginatedMessage& from);
  void MergeFrom(const TimePaginatedMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimePaginatedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .protocol.TimeMessage timeMessage = 1;
  bool has_timemessage() const;
  void clear_timemessage();
  static const int kTimeMessageFieldNumber = 1;
  const ::protocol::TimeMessage& timemessage() const;
  ::protocol::TimeMessage* mutable_timemessage();
  ::protocol::TimeMessage* release_timemessage();
  void set_allocated_timemessage(::protocol::TimeMessage* timemessage);

  // int64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // int64 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TimePaginatedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protocol::TimeMessage* timemessage_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 limit_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class AccountNetMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AccountNetMessage) */ {
 public:
  AccountNetMessage();
  virtual ~AccountNetMessage();

  AccountNetMessage(const AccountNetMessage& from);

  inline AccountNetMessage& operator=(const AccountNetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountNetMessage(AccountNetMessage&& from) noexcept
    : AccountNetMessage() {
    *this = ::std::move(from);
  }

  inline AccountNetMessage& operator=(AccountNetMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountNetMessage& default_instance();

  static inline const AccountNetMessage* internal_default_instance() {
    return reinterpret_cast<const AccountNetMessage*>(
               &_AccountNetMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(AccountNetMessage* other);
  friend void swap(AccountNetMessage& a, AccountNetMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountNetMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountNetMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountNetMessage& from);
  void MergeFrom(const AccountNetMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountNetMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, int64> assetNetUsed = 5;
  int assetnetused_size() const;
  void clear_assetnetused();
  static const int kAssetNetUsedFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
      assetnetused() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
      mutable_assetnetused();

  // map<string, int64> assetNetLimit = 6;
  int assetnetlimit_size() const;
  void clear_assetnetlimit();
  static const int kAssetNetLimitFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
      assetnetlimit() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
      mutable_assetnetlimit();

  // int64 freeNetUsed = 1;
  void clear_freenetused();
  static const int kFreeNetUsedFieldNumber = 1;
  ::google::protobuf::int64 freenetused() const;
  void set_freenetused(::google::protobuf::int64 value);

  // int64 freeNetLimit = 2;
  void clear_freenetlimit();
  static const int kFreeNetLimitFieldNumber = 2;
  ::google::protobuf::int64 freenetlimit() const;
  void set_freenetlimit(::google::protobuf::int64 value);

  // int64 NetUsed = 3;
  void clear_netused();
  static const int kNetUsedFieldNumber = 3;
  ::google::protobuf::int64 netused() const;
  void set_netused(::google::protobuf::int64 value);

  // int64 NetLimit = 4;
  void clear_netlimit();
  static const int kNetLimitFieldNumber = 4;
  ::google::protobuf::int64 netlimit() const;
  void set_netlimit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.AccountNetMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class AccountNetMessage_AssetNetUsedEntry : public ::google::protobuf::internal::MapEntry<AccountNetMessage_AssetNetUsedEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<AccountNetMessage_AssetNetUsedEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > SuperType;
    AccountNetMessage_AssetNetUsedEntry();
    AccountNetMessage_AssetNetUsedEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const AccountNetMessage_AssetNetUsedEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_AccountNetMessage_AssetNetUsedEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      AccountNetMessage_AssetNetUsedEntry,
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > assetnetused_;
  private:
  public:
  class AccountNetMessage_AssetNetLimitEntry : public ::google::protobuf::internal::MapEntry<AccountNetMessage_AssetNetLimitEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<AccountNetMessage_AssetNetLimitEntry, 
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > SuperType;
    AccountNetMessage_AssetNetLimitEntry();
    AccountNetMessage_AssetNetLimitEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const AccountNetMessage_AssetNetLimitEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_AccountNetMessage_AssetNetLimitEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      AccountNetMessage_AssetNetLimitEntry,
      ::std::string, ::google::protobuf::int64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      0 > assetnetlimit_;
  private:
  ::google::protobuf::int64 freenetused_;
  ::google::protobuf::int64 freenetlimit_;
  ::google::protobuf::int64 netused_;
  ::google::protobuf::int64 netlimit_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fapi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Return

// bool result = 1;
inline void Return::clear_result() {
  result_ = false;
}
inline bool Return::result() const {
  // @@protoc_insertion_point(field_get:protocol.Return.result)
  return result_;
}
inline void Return::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:protocol.Return.result)
}

// .protocol.Return.response_code code = 2;
inline void Return::clear_code() {
  code_ = 0;
}
inline ::protocol::Return_response_code Return::code() const {
  // @@protoc_insertion_point(field_get:protocol.Return.code)
  return static_cast< ::protocol::Return_response_code >(code_);
}
inline void Return::set_code(::protocol::Return_response_code value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:protocol.Return.code)
}

// bytes message = 3;
inline void Return::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Return::message() const {
  // @@protoc_insertion_point(field_get:protocol.Return.message)
  return message_.GetNoArena();
}
inline void Return::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Return.message)
}
#if LANG_CXX11
inline void Return::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Return.message)
}
#endif
inline void Return::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Return.message)
}
inline void Return::set_message(const void* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Return.message)
}
inline ::std::string* Return::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Return.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Return::release_message() {
  // @@protoc_insertion_point(field_release:protocol.Return.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Return::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:protocol.Return.message)
}

// -------------------------------------------------------------------

// BlockReference

// int64 block_num = 1;
inline void BlockReference::clear_block_num() {
  block_num_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockReference::block_num() const {
  // @@protoc_insertion_point(field_get:protocol.BlockReference.block_num)
  return block_num_;
}
inline void BlockReference::set_block_num(::google::protobuf::int64 value) {
  
  block_num_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockReference.block_num)
}

// bytes block_hash = 2;
inline void BlockReference::clear_block_hash() {
  block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockReference::block_hash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockReference.block_hash)
  return block_hash_.GetNoArena();
}
inline void BlockReference::set_block_hash(const ::std::string& value) {
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockReference.block_hash)
}
#if LANG_CXX11
inline void BlockReference::set_block_hash(::std::string&& value) {
  
  block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockReference.block_hash)
}
#endif
inline void BlockReference::set_block_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockReference.block_hash)
}
inline void BlockReference::set_block_hash(const void* value, size_t size) {
  
  block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockReference.block_hash)
}
inline ::std::string* BlockReference::mutable_block_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockReference.block_hash)
  return block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockReference::release_block_hash() {
  // @@protoc_insertion_point(field_release:protocol.BlockReference.block_hash)
  
  return block_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockReference::set_allocated_block_hash(::std::string* block_hash) {
  if (block_hash != NULL) {
    
  } else {
    
  }
  block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockReference.block_hash)
}

// -------------------------------------------------------------------

// WitnessList

// repeated .protocol.Witness witnesses = 1;
inline int WitnessList::witnesses_size() const {
  return witnesses_.size();
}
inline void WitnessList::clear_witnesses() {
  witnesses_.Clear();
}
inline const ::protocol::Witness& WitnessList::witnesses(int index) const {
  // @@protoc_insertion_point(field_get:protocol.WitnessList.witnesses)
  return witnesses_.Get(index);
}
inline ::protocol::Witness* WitnessList::mutable_witnesses(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.WitnessList.witnesses)
  return witnesses_.Mutable(index);
}
inline ::protocol::Witness* WitnessList::add_witnesses() {
  // @@protoc_insertion_point(field_add:protocol.WitnessList.witnesses)
  return witnesses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Witness >*
WitnessList::mutable_witnesses() {
  // @@protoc_insertion_point(field_mutable_list:protocol.WitnessList.witnesses)
  return &witnesses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Witness >&
WitnessList::witnesses() const {
  // @@protoc_insertion_point(field_list:protocol.WitnessList.witnesses)
  return witnesses_;
}

// -------------------------------------------------------------------

// AssetIssueList

// repeated .protocol.AssetIssueContract assetIssue = 1;
inline int AssetIssueList::assetissue_size() const {
  return assetissue_.size();
}
inline void AssetIssueList::clear_assetissue() {
  assetissue_.Clear();
}
inline const ::protocol::AssetIssueContract& AssetIssueList::assetissue(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueList.assetIssue)
  return assetissue_.Get(index);
}
inline ::protocol::AssetIssueContract* AssetIssueList::mutable_assetissue(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueList.assetIssue)
  return assetissue_.Mutable(index);
}
inline ::protocol::AssetIssueContract* AssetIssueList::add_assetissue() {
  // @@protoc_insertion_point(field_add:protocol.AssetIssueList.assetIssue)
  return assetissue_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::AssetIssueContract >*
AssetIssueList::mutable_assetissue() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AssetIssueList.assetIssue)
  return &assetissue_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::AssetIssueContract >&
AssetIssueList::assetissue() const {
  // @@protoc_insertion_point(field_list:protocol.AssetIssueList.assetIssue)
  return assetissue_;
}

// -------------------------------------------------------------------

// BlockList

// repeated .protocol.Block block = 1;
inline int BlockList::block_size() const {
  return block_.size();
}
inline void BlockList::clear_block() {
  block_.Clear();
}
inline const ::protocol::Block& BlockList::block(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BlockList.block)
  return block_.Get(index);
}
inline ::protocol::Block* BlockList::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BlockList.block)
  return block_.Mutable(index);
}
inline ::protocol::Block* BlockList::add_block() {
  // @@protoc_insertion_point(field_add:protocol.BlockList.block)
  return block_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Block >*
BlockList::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BlockList.block)
  return &block_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Block >&
BlockList::block() const {
  // @@protoc_insertion_point(field_list:protocol.BlockList.block)
  return block_;
}

// -------------------------------------------------------------------

// TransactionList

// repeated .protocol.Transaction transaction = 1;
inline int TransactionList::transaction_size() const {
  return transaction_.size();
}
inline void TransactionList::clear_transaction() {
  transaction_.Clear();
}
inline const ::protocol::Transaction& TransactionList::transaction(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionList.transaction)
  return transaction_.Get(index);
}
inline ::protocol::Transaction* TransactionList::mutable_transaction(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionList.transaction)
  return transaction_.Mutable(index);
}
inline ::protocol::Transaction* TransactionList::add_transaction() {
  // @@protoc_insertion_point(field_add:protocol.TransactionList.transaction)
  return transaction_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >*
TransactionList::mutable_transaction() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionList.transaction)
  return &transaction_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction >&
TransactionList::transaction() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionList.transaction)
  return transaction_;
}

// -------------------------------------------------------------------

// NodeList

// repeated .protocol.Node nodes = 1;
inline int NodeList::nodes_size() const {
  return nodes_.size();
}
inline void NodeList::clear_nodes() {
  nodes_.Clear();
}
inline const ::protocol::Node& NodeList::nodes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.NodeList.nodes)
  return nodes_.Get(index);
}
inline ::protocol::Node* NodeList::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.NodeList.nodes)
  return nodes_.Mutable(index);
}
inline ::protocol::Node* NodeList::add_nodes() {
  // @@protoc_insertion_point(field_add:protocol.NodeList.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Node >*
NodeList::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.NodeList.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Node >&
NodeList::nodes() const {
  // @@protoc_insertion_point(field_list:protocol.NodeList.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// Node

// .protocol.Address address = 1;
inline bool Node::has_address() const {
  return this != internal_default_instance() && address_ != NULL;
}
inline void Node::clear_address() {
  if (GetArenaNoVirtual() == NULL && address_ != NULL) delete address_;
  address_ = NULL;
}
inline const ::protocol::Address& Node::address() const {
  const ::protocol::Address* p = address_;
  // @@protoc_insertion_point(field_get:protocol.Node.address)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::Address*>(
      &::protocol::_Address_default_instance_);
}
inline ::protocol::Address* Node::mutable_address() {
  
  if (address_ == NULL) {
    address_ = new ::protocol::Address;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Node.address)
  return address_;
}
inline ::protocol::Address* Node::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Node.address)
  
  ::protocol::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Node::set_allocated_address(::protocol::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Node.address)
}

// -------------------------------------------------------------------

// Address

// bytes host = 1;
inline void Address::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Address::host() const {
  // @@protoc_insertion_point(field_get:protocol.Address.host)
  return host_.GetNoArena();
}
inline void Address::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Address.host)
}
#if LANG_CXX11
inline void Address::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Address.host)
}
#endif
inline void Address::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Address.host)
}
inline void Address::set_host(const void* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Address.host)
}
inline ::std::string* Address::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Address.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_host() {
  // @@protoc_insertion_point(field_release:protocol.Address.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:protocol.Address.host)
}

// int32 port = 2;
inline void Address::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:protocol.Address.port)
  return port_;
}
inline void Address::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:protocol.Address.port)
}

// -------------------------------------------------------------------

// EmptyMessage

// -------------------------------------------------------------------

// NumberMessage

// int64 num = 1;
inline void NumberMessage::clear_num() {
  num_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NumberMessage::num() const {
  // @@protoc_insertion_point(field_get:protocol.NumberMessage.num)
  return num_;
}
inline void NumberMessage::set_num(::google::protobuf::int64 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:protocol.NumberMessage.num)
}

// -------------------------------------------------------------------

// BytesMessage

// bytes value = 1;
inline void BytesMessage::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BytesMessage::value() const {
  // @@protoc_insertion_point(field_get:protocol.BytesMessage.value)
  return value_.GetNoArena();
}
inline void BytesMessage::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BytesMessage.value)
}
#if LANG_CXX11
inline void BytesMessage::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BytesMessage.value)
}
#endif
inline void BytesMessage::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BytesMessage.value)
}
inline void BytesMessage::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BytesMessage.value)
}
inline ::std::string* BytesMessage::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BytesMessage.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytesMessage::release_value() {
  // @@protoc_insertion_point(field_release:protocol.BytesMessage.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytesMessage::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:protocol.BytesMessage.value)
}

// -------------------------------------------------------------------

// TimeMessage

// int64 beginInMilliseconds = 1;
inline void TimeMessage::clear_begininmilliseconds() {
  begininmilliseconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TimeMessage::begininmilliseconds() const {
  // @@protoc_insertion_point(field_get:protocol.TimeMessage.beginInMilliseconds)
  return begininmilliseconds_;
}
inline void TimeMessage::set_begininmilliseconds(::google::protobuf::int64 value) {
  
  begininmilliseconds_ = value;
  // @@protoc_insertion_point(field_set:protocol.TimeMessage.beginInMilliseconds)
}

// int64 endInMilliseconds = 2;
inline void TimeMessage::clear_endinmilliseconds() {
  endinmilliseconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TimeMessage::endinmilliseconds() const {
  // @@protoc_insertion_point(field_get:protocol.TimeMessage.endInMilliseconds)
  return endinmilliseconds_;
}
inline void TimeMessage::set_endinmilliseconds(::google::protobuf::int64 value) {
  
  endinmilliseconds_ = value;
  // @@protoc_insertion_point(field_set:protocol.TimeMessage.endInMilliseconds)
}

// -------------------------------------------------------------------

// BlockLimit

// int64 startNum = 1;
inline void BlockLimit::clear_startnum() {
  startnum_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockLimit::startnum() const {
  // @@protoc_insertion_point(field_get:protocol.BlockLimit.startNum)
  return startnum_;
}
inline void BlockLimit::set_startnum(::google::protobuf::int64 value) {
  
  startnum_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockLimit.startNum)
}

// int64 endNum = 2;
inline void BlockLimit::clear_endnum() {
  endnum_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockLimit::endnum() const {
  // @@protoc_insertion_point(field_get:protocol.BlockLimit.endNum)
  return endnum_;
}
inline void BlockLimit::set_endnum(::google::protobuf::int64 value) {
  
  endnum_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockLimit.endNum)
}

// -------------------------------------------------------------------

// TransactionLimit

// bytes transactionId = 1;
inline void TransactionLimit::clear_transactionid() {
  transactionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionLimit::transactionid() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLimit.transactionId)
  return transactionid_.GetNoArena();
}
inline void TransactionLimit::set_transactionid(const ::std::string& value) {
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransactionLimit.transactionId)
}
#if LANG_CXX11
inline void TransactionLimit::set_transactionid(::std::string&& value) {
  
  transactionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransactionLimit.transactionId)
}
#endif
inline void TransactionLimit::set_transactionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransactionLimit.transactionId)
}
inline void TransactionLimit::set_transactionid(const void* value, size_t size) {
  
  transactionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionLimit.transactionId)
}
inline ::std::string* TransactionLimit::mutable_transactionid() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransactionLimit.transactionId)
  return transactionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionLimit::release_transactionid() {
  // @@protoc_insertion_point(field_release:protocol.TransactionLimit.transactionId)
  
  return transactionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionLimit::set_allocated_transactionid(::std::string* transactionid) {
  if (transactionid != NULL) {
    
  } else {
    
  }
  transactionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transactionid);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionLimit.transactionId)
}

// int64 limitNum = 2;
inline void TransactionLimit::clear_limitnum() {
  limitnum_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionLimit::limitnum() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLimit.limitNum)
  return limitnum_;
}
inline void TransactionLimit::set_limitnum(::google::protobuf::int64 value) {
  
  limitnum_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionLimit.limitNum)
}

// -------------------------------------------------------------------

// AccountPaginated

// .protocol.Account account = 1;
inline bool AccountPaginated::has_account() const {
  return this != internal_default_instance() && account_ != NULL;
}
inline void AccountPaginated::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) delete account_;
  account_ = NULL;
}
inline const ::protocol::Account& AccountPaginated::account() const {
  const ::protocol::Account* p = account_;
  // @@protoc_insertion_point(field_get:protocol.AccountPaginated.account)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::Account*>(
      &::protocol::_Account_default_instance_);
}
inline ::protocol::Account* AccountPaginated::mutable_account() {
  
  if (account_ == NULL) {
    account_ = new ::protocol::Account;
  }
  // @@protoc_insertion_point(field_mutable:protocol.AccountPaginated.account)
  return account_;
}
inline ::protocol::Account* AccountPaginated::release_account() {
  // @@protoc_insertion_point(field_release:protocol.AccountPaginated.account)
  
  ::protocol::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void AccountPaginated::set_allocated_account(::protocol::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountPaginated.account)
}

// int64 offset = 2;
inline void AccountPaginated::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountPaginated::offset() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPaginated.offset)
  return offset_;
}
inline void AccountPaginated::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountPaginated.offset)
}

// int64 limit = 3;
inline void AccountPaginated::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountPaginated::limit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPaginated.limit)
  return limit_;
}
inline void AccountPaginated::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountPaginated.limit)
}

// -------------------------------------------------------------------

// TimePaginatedMessage

// .protocol.TimeMessage timeMessage = 1;
inline bool TimePaginatedMessage::has_timemessage() const {
  return this != internal_default_instance() && timemessage_ != NULL;
}
inline void TimePaginatedMessage::clear_timemessage() {
  if (GetArenaNoVirtual() == NULL && timemessage_ != NULL) delete timemessage_;
  timemessage_ = NULL;
}
inline const ::protocol::TimeMessage& TimePaginatedMessage::timemessage() const {
  const ::protocol::TimeMessage* p = timemessage_;
  // @@protoc_insertion_point(field_get:protocol.TimePaginatedMessage.timeMessage)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::TimeMessage*>(
      &::protocol::_TimeMessage_default_instance_);
}
inline ::protocol::TimeMessage* TimePaginatedMessage::mutable_timemessage() {
  
  if (timemessage_ == NULL) {
    timemessage_ = new ::protocol::TimeMessage;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TimePaginatedMessage.timeMessage)
  return timemessage_;
}
inline ::protocol::TimeMessage* TimePaginatedMessage::release_timemessage() {
  // @@protoc_insertion_point(field_release:protocol.TimePaginatedMessage.timeMessage)
  
  ::protocol::TimeMessage* temp = timemessage_;
  timemessage_ = NULL;
  return temp;
}
inline void TimePaginatedMessage::set_allocated_timemessage(::protocol::TimeMessage* timemessage) {
  delete timemessage_;
  timemessage_ = timemessage;
  if (timemessage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TimePaginatedMessage.timeMessage)
}

// int64 offset = 2;
inline void TimePaginatedMessage::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TimePaginatedMessage::offset() const {
  // @@protoc_insertion_point(field_get:protocol.TimePaginatedMessage.offset)
  return offset_;
}
inline void TimePaginatedMessage::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:protocol.TimePaginatedMessage.offset)
}

// int64 limit = 3;
inline void TimePaginatedMessage::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TimePaginatedMessage::limit() const {
  // @@protoc_insertion_point(field_get:protocol.TimePaginatedMessage.limit)
  return limit_;
}
inline void TimePaginatedMessage::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.TimePaginatedMessage.limit)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AccountNetMessage

// int64 freeNetUsed = 1;
inline void AccountNetMessage::clear_freenetused() {
  freenetused_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountNetMessage::freenetused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.freeNetUsed)
  return freenetused_;
}
inline void AccountNetMessage::set_freenetused(::google::protobuf::int64 value) {
  
  freenetused_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.freeNetUsed)
}

// int64 freeNetLimit = 2;
inline void AccountNetMessage::clear_freenetlimit() {
  freenetlimit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountNetMessage::freenetlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.freeNetLimit)
  return freenetlimit_;
}
inline void AccountNetMessage::set_freenetlimit(::google::protobuf::int64 value) {
  
  freenetlimit_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.freeNetLimit)
}

// int64 NetUsed = 3;
inline void AccountNetMessage::clear_netused() {
  netused_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountNetMessage::netused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.NetUsed)
  return netused_;
}
inline void AccountNetMessage::set_netused(::google::protobuf::int64 value) {
  
  netused_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.NetUsed)
}

// int64 NetLimit = 4;
inline void AccountNetMessage::clear_netlimit() {
  netlimit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountNetMessage::netlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.NetLimit)
  return netlimit_;
}
inline void AccountNetMessage::set_netlimit(::google::protobuf::int64 value) {
  
  netlimit_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.NetLimit)
}

// map<string, int64> assetNetUsed = 5;
inline int AccountNetMessage::assetnetused_size() const {
  return assetnetused_.size();
}
inline void AccountNetMessage::clear_assetnetused() {
  assetnetused_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
AccountNetMessage::assetnetused() const {
  // @@protoc_insertion_point(field_map:protocol.AccountNetMessage.assetNetUsed)
  return assetnetused_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
AccountNetMessage::mutable_assetnetused() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountNetMessage.assetNetUsed)
  return assetnetused_.MutableMap();
}

// map<string, int64> assetNetLimit = 6;
inline int AccountNetMessage::assetnetlimit_size() const {
  return assetnetlimit_.size();
}
inline void AccountNetMessage::clear_assetnetlimit() {
  assetnetlimit_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
AccountNetMessage::assetnetlimit() const {
  // @@protoc_insertion_point(field_map:protocol.AccountNetMessage.assetNetLimit)
  return assetnetlimit_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
AccountNetMessage::mutable_assetnetlimit() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountNetMessage.assetNetLimit)
  return assetnetlimit_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Return_response_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Return_response_code>() {
  return ::protocol::Return_response_code_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2fapi_2eproto__INCLUDED
